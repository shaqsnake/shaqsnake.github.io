<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



















  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.cat.net/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.6" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.6">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.6" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.6',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: 'YVZYJ3I4RS',
      apiKey: '04e2954a2354e8d0e30eda3ab18598b0',
      indexName: 'myBlogIndex',
      hits: {"per_page":10},
      labels: {"input_placeholder":"搜索...","hits_empty":"无法检索到包含 ${query} 关键字的文章","hits_stats":"共检索到 ${hits} 篇文章， 耗时 ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="CHAPTER 2 Elements of Computer System OrganizationOVERVIEW实践中最重要的三个对计算机系统组件的抽象是：  The memory（存储器） The interpreter （解释器） The communication link (通信链路）  设计者运用这三个抽象来组织物理硬件的结构，不仅仅因为它们是直接的通道，还因为：  它们提供了最基础">
<meta name="keywords" content="读书笔记,computer design">
<meta property="og:type" content="article">
<meta property="og:title" content="Principles of Computer System Design 读书笔记 II">
<meta property="og:url" content="http://shaqsnake.github.io/2018/04/01/PCSD-02.html">
<meta property="og:site_name" content="夏秋的博客">
<meta property="og:description" content="CHAPTER 2 Elements of Computer System OrganizationOVERVIEW实践中最重要的三个对计算机系统组件的抽象是：  The memory（存储器） The interpreter （解释器） The communication link (通信链路）  设计者运用这三个抽象来组织物理硬件的结构，不仅仅因为它们是直接的通道，还因为：  它们提供了最基础">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15221591682350.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15222444178749.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15224131707131.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15224148791780.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15224151583737.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15225942677247.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15225947387759.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15225950877197.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15227672437883.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15228632272684.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15228650610668.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15228652746718.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15232871548588.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15233660002452.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15234554384088.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15234562457503.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15238003056516.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15238006083283.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15238869739270.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15239824190641.jpg">
<meta property="og:image" content="http://p6ayvlg30.bkt.clouddn.com/15239832305990.jpg">
<meta property="og:updated_time" content="2018-04-17T16:55:06.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Principles of Computer System Design 读书笔记 II">
<meta name="twitter:description" content="CHAPTER 2 Elements of Computer System OrganizationOVERVIEW实践中最重要的三个对计算机系统组件的抽象是：  The memory（存储器） The interpreter （解释器） The communication link (通信链路）  设计者运用这三个抽象来组织物理硬件的结构，不仅仅因为它们是直接的通道，还因为：  它们提供了最基础">
<meta name="twitter:image" content="http://p6ayvlg30.bkt.clouddn.com/15221591682350.jpg">



  <link rel="alternate" href="/atom.xml" title="夏秋的博客" type="application/atom+xml" />




  <link rel="canonical" href="http://shaqsnake.github.io/2018/04/01/PCSD-02.html"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Principles of Computer System Design 读书笔记 II | 夏秋的博客</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-48273205-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-48273205-1');
</script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">夏秋的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Code Monkey's Blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
</li>

      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shaqsnake.github.io/2018/04/01/PCSD-02.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="夏秋">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="夏秋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Principles of Computer System Design 读书笔记 II</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T00:00:00+08:00">2018-04-01</time>
            

            
            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/04/01/PCSD-02.html" class="leancloud_visitors" data-flag-title="Principles of Computer System Design 读书笔记 II">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数：</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计：</span>
                
                <span title="字数统计">11k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长&asymp;</span>
                
                <span title="阅读时长">0:54</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="CHAPTER-2-Elements-of-Computer-System-Organization"><a href="#CHAPTER-2-Elements-of-Computer-System-Organization" class="headerlink" title="CHAPTER 2 Elements of Computer System Organization"></a>CHAPTER 2 Elements of Computer System Organization</h1><h2 id="OVERVIEW"><a href="#OVERVIEW" class="headerlink" title="OVERVIEW"></a>OVERVIEW</h2><p>实践中最重要的三个对计算机系统组件的抽象是：</p>
<ul>
<li>The memory（存储器）</li>
<li>The interpreter （解释器）</li>
<li>The communication link (通信链路）</li>
</ul>
<p>设计者运用这三个抽象来组织物理硬件的结构，不仅仅因为它们是直接的通道，还因为：</p>
<ul>
<li>它们提供了最基础的函数，包括调用(取值），处理和通信；</li>
<li>它们也是对硬件最简单，接口最清晰的抽象。</li>
</ul>
<p><strong>Reference</strong> - 引用，一种将计算机系统中交互组件抽象的方式。通常一个组件用过特定的命名方式通另一个组件相连。</p>
<a id="more"></a>
<h2 id="2-1-THE-THREE-FUNDAMENTAL-ABSTRACTIONS"><a href="#2-1-THE-THREE-FUNDAMENTAL-ABSTRACTIONS" class="headerlink" title="2.1 THE THREE FUNDAMENTAL ABSTRACTIONS"></a>2.1 THE THREE FUNDAMENTAL ABSTRACTIONS</h2><h3 id="2-1-1-Memory"><a href="#2-1-1-Memory" class="headerlink" title="2.1.1 Memory"></a>2.1.1 Memory</h3><p><strong>Memory</strong> - 存储器，是系统在做计算时用来储存数值的组件。</p>
<p><em>注解：文中的上下文中Memory是更广泛含义的存储，包括内存，文件储存或一些其它的存储形式的总称。</em></p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15221591682350.jpg" alt=""></p>
<p>虽然图 2.1 列出了许多种存储，但所有的存储都可以被抽象成一个模块，一个包括“<strong>读</strong>”和“<strong>写</strong>”操作的模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WRITE(name, value)</span><br><span class="line">value &lt;- READ(name)</span><br></pre></td></tr></table></figure>
<p>存储器分为：</p>
<ul>
<li>易失性存储器(volatile memory)</li>
<li>非易失性存储器(non-volatile memory or stable storage)</li>
</ul>
<p>硬件层的存储器设备在存储单元上来读写的数据，通常是一段固定长度的bit，比如bytes(8bits)，words(number of bytes, typically 2, 4, 8), lines(several words)和block(a number of bytes, usually a power of 2)。</p>
<p>高层次的存储器系统也是读写一段连续的bit，但在长度上更灵活，可以是record，segment或者file。</p>
<h4 id="2-1-1-1-Read-Write-Coherence-and-Atomicity"><a href="#2-1-1-1-Read-Write-Coherence-and-Atomicity" class="headerlink" title="2.1.1.1 Read/Write Coherence and Atomicity"></a>2.1.1.1 Read/Write Coherence and Atomicity</h4><p>存储器有两个特性：</p>
<ul>
<li><strong>read/write coherence</strong> - 读写一致性</li>
<li><strong>before-or-after atomicity</strong> - 前后原子性</li>
</ul>
<p>设计者通常为简单地假定这两个特性，但是这种假设是有风险且容易出错的，有许多情况都会威胁到存储器的读写一致性和前后原子性：</p>
<ul>
<li><strong>Concurrency</strong> - 并发</li>
<li><strong>Remote storage</strong> - 远程存储，延迟带来的问题；</li>
<li><strong>Performance enhancements</strong> - 性能优化，在一些编译器和高性能处理器优化过程中可能会改变操作存储器的顺序，从而破坏读写一致性；</li>
<li><strong>Cell size incommensurate with value size</strong> - 存储单元与数值大小不匹配，一个非常大的数值可能会占据很多存储单元，而在读写过程中由于只能一次操作一个存储单元，可能会破坏前后原子性。同样在操作小数值时，两个同时对同一存储单元进行的写操作也会破坏原子性。</li>
<li><strong>Replicated storage</strong> - 分布式（分片）存储。</li>
</ul>
<p>系统设计者可能会同时面对上面的多种情况，其中分布式和远程延迟是最具挑战的，有时设计者会设计出弱一致性的存储。<br><em>注解：可参考分布式系统CAP理论<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[Perspectives on the CAP Theorem](https://groups.csail.mit.edu/tds/papers/Gilbert/Brewer2.pdf)">[0]</span></a></sup></em></p>
<p>最后我们通常会假定物理的存储设备保证了单存储单元的读写一致性，但是对于多存储单元的前后一致性就需要上层的具体实现来保证了。</p>
<h3 id="2-1-1-2-Memory-Latency"><a href="#2-1-1-2-Memory-Latency" class="headerlink" title="2.1.1.2 Memory Latency"></a>2.1.1.2 Memory Latency</h3><p><strong>Access time / Latency</strong> - 磁盘读或写操作消耗的时间。</p>
<p><strong>Random access memory(RAM)</strong> - 随机存取存储器<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[随机存取存储器](https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8)（英语：Random Access Memory，RAM），是与CPU直接交换数据的内部存储器，也叫主存。[1]它可以随时读写（刷新时除外，见下文），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。">[1]</span></a></sup></p>
<p>对于大块数据的<strong>READ</strong>和<strong>WRITE</strong>操作有时又被称为<strong>GET</strong>和<strong>PUT</strong>，传统上<strong>memory</strong>也特指随机存取的易失性存储器，而<strong>storage</strong>指非易失性的存储器，<strong>storage</strong>对大块数据的读写是<strong>GET</strong>（取）和<strong>PUT</strong>（存）。</p>
<h3 id="2-1-1-3-Memory-Names-and-Addresses"><a href="#2-1-1-3-Memory-Names-and-Addresses" class="headerlink" title="2.1.1.3 Memory Names and Addresses"></a>2.1.1.3 Memory Names and Addresses</h3><p><img src="http://p6ayvlg30.bkt.clouddn.com/15222444178749.jpg" alt=""></p>
<p>图 2.2 展示了<strong>结合储存(Associativity memory)</strong>的应用架构，通常结合储存位于地址储存的上层，负责高效返回需要经常查询的值。</p>
<p><em>注解：其实就是我们熟悉的缓存(Cache)</em></p>
<h3 id="2-1-1-4-Exploiting-the-Memory-Abstraction-RAID"><a href="#2-1-1-4-Exploiting-the-Memory-Abstraction-RAID" class="headerlink" title="2.1.1.4 Exploiting the Memory Abstraction: RAID"></a>2.1.1.4 Exploiting the Memory Abstraction: RAID</h3><p><strong>RAID</strong><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[独立硬盘冗余阵列（RAID, Redundant Array of Independent Disks）](https://zh.wikipedia.org/wiki/RAID)，旧称廉价磁盘冗余阵列（Redundant Array of Inexpensive Disks），简称磁盘阵列。其基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。">[2]</span></a></sup>的全称是 Redundant Array of Independent(or Inexpensive) Disks，它如图 2.2 所示，由许多磁盘和一个控制器组成，其中控制器的接口同单个磁盘的数据接口是一样的。</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15224131707131.jpg" alt=""></p>
<p><em>注解：这个图是不是很像负载均衡</em></p>
<p>RAID控制器会将READ和WRITE的请求通过接口分发到磁盘上。RAID主要作用有两个：</p>
<ul>
<li>提高性能，并发的读写磁盘；</li>
<li>保护数据，多个磁盘有多个数据备份。</li>
</ul>
<h3 id="2-1-2-Interpreters"><a href="#2-1-2-Interpreters" class="headerlink" title="2.1.2 Interpreters"></a>2.1.2 Interpreters</h3><p>图 2.4 列举计算机中常见的解释器。</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15224148791780.jpg" alt=""></p>
<p><strong>Interpreter</strong> - 解释器，包括了三个基本元素：</p>
<ul>
<li>指令引用，告诉解释器去哪里寻找下一个指令；</li>
<li>指令集，定义了解释器将要执行的指令的集合，这些指令通过上面的指令引用来获得；</li>
<li>环境引用，告诉了解释器哪里去获得相关的环境，环境的状态会影响当期指令的进行的动作。</li>
</ul>
<p>图 2.5 是程序运行时解释器的流程图和伪代码，解释器从环境引用里获得当前环境，从指令引用中获得程序指令，然后执行指令，此操作可能会改变环境中的数据，当完成指令后解释器会继续上面的流程执行下一个指令，周而复始。但在这个过程中有一个事件会让解释器停止当前成俗的工作，这就是中断(<strong>Interrupts</strong>)。被中断的程序不在有解释器的控制权，相应地一个新程序会接管解释器，更新指令和环境。</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15224151583737.jpg" alt=""></p>
<p>许多系统都有不止一个解释器，多解释器通常是异步(<strong>Asynchronous</strong>)工作的，导致即使同一个程序中，解释器的进度都会不一致。正是由于解释器的异步导致内存中的读写一致性和前后原子性变成了设计的一个难点。</p>
<h4 id="2-1-2-1-Processors"><a href="#2-1-2-1-Processors" class="headerlink" title="2.1.2.1 Processors"></a>2.1.2.1 Processors</h4><p>通常处理器就是一个解释器的具体实现，处理器的指令引用称作程序计数器(<strong>PC - Program Counter</strong>)，存在处理器的高速缓存中。PC中包含了具体指令的内存地址，而环境引用放在了寄存器(<strong>Register</strong>)中。</p>
<p>处理器的指令集包括了一些计算表达式，不如加(<strong>ADD</strong>)、减(<strong>SUB</strong>)、数据比较(<strong>CMP</strong>)和指令更替(<strong>JMP</strong>)等等，这些指令存储在处理器的寄存器里，有时昵称为“操作代码(<strong>Op-codes</strong>)。</p>
<p>指令集还包括了许多在寄存器和内存之间移动数据的操作：</p>
<ul>
<li>LOAD - 表示寄存器从内存中读取数值；</li>
<li>STORE - 表示把寄存器里的数值写到内存单元上。</li>
</ul>
<p>处理器提供了一个先进后出的数据结构——栈，在内存上实现程序的调用。处理器里有个专门的寄存器来存储栈顶的内存地址(Stack point)。</p>
<p>最后，处理器还实现了中断，中断可以让处理器检测到运行程序中的问题（比如程序试图执行一个解释器无法执行的指令，比如除零）。中断也可以是因为外部的一些信号，让处理器处理一些更紧急的工作。</p>
<h4 id="2-1-2-2-Interpreter-Layers"><a href="#2-1-2-2-Interpreter-Layers" class="headerlink" title="2.1.2.2 Interpreter Layers"></a>2.1.2.2 Interpreter Layers</h4><p>解释器通常是用层次结构来描述的，最底层一般包括的是硬件的最基本指令，上面的层次会在此基础上提供一些复杂的指令集，如图 2.6 所示：</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15225942677247.jpg" alt=""></p>
<p>图 2.7 列举的一个用Java实现的日历程序中指令如何从高层级往低层级转化的过程：</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15225947387759.jpg" alt=""></p>
<p><em>注解：程序的任务操作或事件都被逐层的翻译给下一层来调用，最后变成硬件能识别的机器语言</em></p>
<h3 id="2-1-3-Communication-Links"><a href="#2-1-3-Communication-Links" class="headerlink" title="2.1.3 Communication Links"></a>2.1.3 Communication Links</h3><p>图 2.8 列举了一些常见的通信链路的技术，其实就是提供了一种让不同的物理组件能够通信交互的途径。</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15225950877197.jpg" alt=""></p>
<p>通信链路可以抽象成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEND(link_name, outgoing_message_buffer)</span><br><span class="line">RECEIVE(link_name, incoming_message_buffer)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SEND</strong>操作指定了具体的通信链路名称(link_name)和需要发送信息内容(message)。</li>
<li><strong>RECEIVE</strong>操作同样指定了link_name和接受的信息。</li>
</ul>
<p><em>注解：因为在内存中字符串内容的通常是以字符串第一个指针和字符串长度来获取的，所以伪代码中用message_buffer来表示message的内容。</em></p>
<p>虽然看起来数据链路的SEND和RECEIVE很像是从一个内存READ或WRITE到另一个内存的操作，看似不需要再抽象出这一层。但是实际上数据链路传输数据的情况要复杂许多（比如网络错误，发送失败等等），需要实现比READ和WRITE更多的细节，所以数据链路的这层抽象还是很有必要的。</p>
<h2 id="2-2-NAMING-IN-COMPUTER-SYSTEMS"><a href="#2-2-NAMING-IN-COMPUTER-SYSTEMS" class="headerlink" title="2.2 NAMING IN COMPUTER SYSTEMS"></a>2.2 NAMING IN COMPUTER SYSTEMS</h2><p>在程序函数中调用对象的两种方式：</p>
<ul>
<li>获得一个对象的拷贝（值）</li>
<li>获得一个对象的命名（引用）</li>
</ul>
<p>虽然在函数中传递参数时只获取另一对象的值显得更模块化，因为在函数内修改对象的值并不会影响到对象本身，但如果需要这个对象更新的状态被更多的函数感知时，传递值就不行了。所以很多程序都提供了可以共享对象的命名机制。<br><em>注解：即C/C++中的指针，其实很多无指针概念的编程语言在传递对象是也是传递的引用。</em></p>
<p>解耦两个对象的有效方式就是通过命名来起到中介代理的作用。<br><em>注解：其实就是说在一个对象里需要用到另一个对象时，只要用那个对象的间接引用（C语言里就是指针）就可以了。</em></p>
<h3 id="2-2-1-The-Naming-Model"><a href="#2-2-1-The-Naming-Model" class="headerlink" title="2.2.1 The Naming Model"></a>2.2.1 The Naming Model</h3><p>命名体系的三要素：</p>
<ul>
<li><strong>Name Space</strong> - 命名空间</li>
<li><strong>Name-mapping algorithm</strong> - 命名映射算法</li>
<li><strong>Universe of values</strong> - 值域</li>
</ul>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15227672437883.jpg" alt=""></p>
<p>如图 2.10，其中命名映射是更根据上下文(Context)来切换的，具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value &lt;- RESOLVE(name, context)</span><br></pre></td></tr></table></figure>
<p>除此之外，还有另外四个操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status &lt;- BIND(name, value, context)</span><br><span class="line">status &lt;- UNBIND(name, context)</span><br><span class="line">list &lt;- ENUMERATE(context)</span><br><span class="line">result &lt;- COMPARE(name1, name2)</span><br></pre></td></tr></table></figure>
<p>第一个操作<strong>BIND</strong>是在特定上下文中为一个命名绑定了一个新值，stauts是执行的状态（是否成功），第二个操作<strong>UNBIND</strong>就是解绑，status同第一个操作。<strong>ENUMERATE</strong>就是列举出当前Context中的所有已被绑定的值。最后<strong>COMPARE</strong>是用来判断两个命名所绑定的值是否相等的。</p>
<p>三种常见的命名映射算法：</p>
<ul>
<li><strong>Table lookup</strong> - 表查找</li>
<li><strong>Recursive lookup</strong> - 递归查找</li>
<li><strong>Multiple lookup</strong> - 重复查找</li>
</ul>
<h3 id="2-2-2-Default-and-Explicit-Context-References"><a href="#2-2-2-Default-and-Explicit-Context-References" class="headerlink" title="2.2.2 Default and Explicit Context References"></a>2.2.2 Default and Explicit Context References</h3><p>当程序解释器遇到一个对象时，需要上下文的引用得到具体的命名映射算法，然后才能通过对象名来进行解析。上下文的引用有两类：</p>
<ul>
<li><strong>Default</strong> - 默认的</li>
<li><strong>Explicit</strong> - 显式的</li>
</ul>
<p>默认的解析器是由解析器提供的，而显示的解析器是由对象所提供，如图 2.12。</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15228632272684.jpg" alt=""></p>
<p><em>注解：图2.12 中显示引用的第二种形式是限定名(qualified name)，现实中的像特定对象的属性(N.x)或XML格式的命名(<xml>X</xml>)都可以认为是限定名。</em></p>
<h3 id="2-2-3-Path-Names-Naming-Networks-and-Recursive-Name-Resolution"><a href="#2-2-3-Path-Names-Naming-Networks-and-Recursive-Name-Resolution" class="headerlink" title="2.2.3 Path Names, Naming Networks, and Recursive Name Resolution"></a>2.2.3 Path Names, Naming Networks, and Recursive Name Resolution</h3><p><img src="http://p6ayvlg30.bkt.clouddn.com/15228650610668.jpg" alt=""></p>
<p>上图都是一些路径名的例子，它们都包含了多层组件名字。解析路径时我们需要不断重复的去识别出命名中最小区别的步部分，比如：</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15228652746718.jpg" alt=""></p>
<p>路径名中常见的一些概念：</p>
<ul>
<li><strong>root</strong> - 根路径</li>
<li><strong>Absolute path name</strong> - 绝对路径</li>
<li><strong>Relative path name</strong> - 相对路径</li>
<li><strong>Synonyms/Aliases</strong> - 别名</li>
<li><strong>Links</strong> - 链接</li>
</ul>
<h3 id="2-2-4-Multiple-Lookup-Searching-through-Layered-Contexts"><a href="#2-2-4-Multiple-Lookup-Searching-through-Layered-Contexts" class="headerlink" title="2.2.4 Multiple Lookup: Searching through Layered Contexts"></a>2.2.4 Multiple Lookup: Searching through Layered Contexts</h3><p>当对象被绑定到多个上下文中，解析对象时需要系统地从不同的上下文中来寻找时，就要用到重复查找，常见的有：</p>
<ul>
<li><strong>Search path</strong> - 查找路径，常用在编程时进行设置，方便编译器去寻找库文件。</li>
</ul>
<p><em>注解：Shell环境中配置的SEARCH_PATH</em></p>
<h3 id="2-2-5-Comparing-Names"><a href="#2-2-5-Comparing-Names" class="headerlink" title="2.2.5 Comparing Names"></a>2.2.5 Comparing Names</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &lt;- COMPARE(name1, name2)</span><br></pre></td></tr></table></figure>
<p>其中result是一个布尔值，True（真）或False（假）。不同的编程语言会提供不同层级的比较，比如两个name的命名是否一致，两个name的值师傅一致，两个name在底层的存储位置是否一致等，比如像LISP<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[LISP](https://zh.wikipedia.org/wiki/LISP)是第一个函数式程序语言，区别于C语言、Fortran等命令型程序语言和Java、C#、Objective-C等面向对象程序语言。">[3]</span></a></sup>语言就提供了三种不同的比较语法 —— EQ（比较参数的名字）、EQU（比较参数的值）、EQUALS（比较整个数据结构）。</p>
<h3 id="2-2-6-Name-Discovery"><a href="#2-2-6-Name-Discovery" class="headerlink" title="2.2.6 Name Discovery"></a>2.2.6 Name Discovery</h3><p>命名发现的两个要素：</p>
<ul>
<li>提供者能表现(Advertise)名字的存在感</li>
<li>使用者能搜索(Search)合适的关键字</li>
</ul>
<h2 id="2-3-ORGANIZING-COMPUTER-SYSTEMS-WITH-NAMES-AND-LAYERS"><a href="#2-3-ORGANIZING-COMPUTER-SYSTEMS-WITH-NAMES-AND-LAYERS" class="headerlink" title="2.3 ORGANIZING COMPUTER SYSTEMS WITH NAMES AND LAYERS"></a>2.3 ORGANIZING COMPUTER SYSTEMS WITH NAMES AND LAYERS</h2><p>图 2.16 展示了一个典型而清晰的计算机三层架构，最底层是硬件组件例如处理器、内存和通信链路等，中间层是操作系统，提供了应用可编程接口(API)，最上层是一些具体的应用程序，如文字处理工具，游戏或网页浏览器等。其中每一层内部也是由层次结构组织起来的。</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15232871548588.jpg" alt=""></p>
<p>软件和硬件实际上可以相互实现对方的大部分功能，所以在的工程设计上就是一种取舍(Trade-off)的结果，主要考量包括了性能，灵活性，易用性等等。</p>
<p>可以发现操作系统层次有一种有意思的现象称为层次跳跃(layer bypass)，就是操作系统只隐藏了底层硬件一部分的高危指令，所以高层次的应用程序实际上可以绕过操作系统去调用硬件的另一部分较安全的指令。</p>
<h3 id="2-3-1-A-Hardware-Layer-The-Bus"><a href="#2-3-1-A-Hardware-Layer-The-Bus" class="headerlink" title="2.3.1 A Hardware Layer: The Bus"></a>2.3.1 A Hardware Layer: The Bus</h3><p>硬件层的实现就包括了本文最开始提到的三种基本抽象，如图 2.17 所示：</p>
<ul>
<li>解释器 —— 处理器解释程序</li>
<li>存储器 —— 内存存储程序和数据</li>
<li>通信链路 —— I/O设备和外界交互</li>
</ul>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15233660002452.jpg" alt=""></p>
<p>多个组件都会接到<strong>总线(Bus)</strong>上，以实现高速的信息传递。总线的基本特征包括：</p>
<ul>
<li><strong>总线接口(Bus Interface)</strong>连接各种组件的地址线，数据线和控制线；</li>
<li><strong>总线仲裁协议(Bus Arbitration Protocol)</strong>限制了组件的行为，即在什么时候可以发送和接受信息，使同一时刻内的信号不会产生混乱；</li>
<li><strong>广播(Broadcast)</strong>保证了连上总线的组件可以接受到每条消息，<strong>总线地址(Bus Address)</strong>保证了特定的消息可以发送给特定的组件。</li>
</ul>
<p>一种常见的总线设计方法被称为<strong>拆分事务(Split-transaction)</strong>。</p>
<p><em>注解：就是把一个完整的操作周期拆分成两个子过程，比如IO读写请求中“主设备请求-&gt;从设备发送-&gt;主设备接受”就被拆分成了“主设备请求-&gt;从设备确认“和“从设备准备发送-&gt;主设备接收“两个阶段的事务，这样在两个事务中间总线的资源可以释放出来被其它设备使用。这个原理和并发中IO的多路复用类似。</em></p>
<p>两个提高总线效率的技术：</p>
<ul>
<li><strong>直接内存访问(Direct Memory Access, DMA)</strong><sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[DMA](https://zh.wikipedia.org/wiki/直接記憶體存取)允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需中央处理器（CPU）介入处理 。">[4]</span></a></sup></li>
<li><strong>内存映射IO(Memory-mapped I/O, MMIO)</strong><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[MMIO](https://zh.wikipedia.org/wiki/存储器映射输入输出)使用相同的地址总线来寻址内存和输入输出设备（简称IO设备），前提是IO设备上的设备内存和寄存器都已经被映射到内存空间的某个地址。">[5]</span></a></sup></li>
</ul>
<blockquote>
<p>The principle of least astonishment<br>People are part of the system. The design should match the user’s experience, expectations, and mental models.</p>
</blockquote>
<p><em>注解：在计算机系统设计时，要让系统易设置，易使用，易编程，易维护。</em></p>
<h3 id="2-3-2-A-Software-Layer-The-File-Abstraction"><a href="#2-3-2-A-Software-Layer-The-File-Abstraction" class="headerlink" title="2.3.2 A Software Layer: The File Abstraction"></a>2.3.2 A Software Layer: The File Abstraction</h3><p>计算机系统中文件的两个特性：</p>
<ul>
<li>持久性(Durable)，可以长期保持在介质中；</li>
<li>实名性(Name)，可以通过文件名来共享。</li>
</ul>
<p>图 2.18 展示了一个应用如何从键盘读取输入，把输入写到文件中以及如歌在显示设备上显示出来的伪代码：</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15234554384088.jpg" alt=""></p>
<p>一个典型的文件系统API包括了<strong>打开(OPEN)</strong>文件，<strong>读写(READ/WRITE)</strong>文件和<strong>关闭(CLOSE)</strong>文件的操作。</p>
<p>OPEN的主要任务包括:</p>
<ul>
<li>给文件创建一个临时的引用名，方便后续READ和WRITE操作；</li>
<li>检查用户是否有权限操作文件；</li>
<li>在文件内容的最开始设置一个游标(Cursor)或文件指针(File Pointer)来记录文件内容的位移(Offset)情况。</li>
</ul>
<p>READ和WRITE根据游标位置和指定的长度来操作读写内容，循环往复把内容读或写到Buf中，一直到文件的末尾才停止。其中写操作也可能会因为存储容量不足而中断。</p>
<p>CLOSE操作释放文件中的所有状态，包括引用名和游标，有些系统会在CLOSE时保证所有对文件的修改都会保存到非易失性存储设备中，有些系统则会在CLOSE后在后台完成这个动作。</p>
<p>现今的文件系统会通过OPEN和CLOSE来标记原子操作的开始和结束，保证：</p>
<ol>
<li>文件系统可以保证并发访问文件时的一致性，比如一个程序在OPEN文件时如果另一个程序想OPEN这个文件，文件系统可以让第二个程序处于等待状态，直到第一个文件CLOSE这个文件。这种一致性的行为又称作<strong>前后原子性(Before-or-after Atomicity)</strong>。</li>
<li>如果文件系统在应用CLOSE文件前宕机了，之前的WRITE操作都不会反映到文件中；如果文件系统在应用CLOSE文件后宕机，所有的WRITE操作都会反映到文件中。这种一致性称为<strong>无中间状态原子性(All-or-nothin Atomicity)</strong></li>
</ol>
<p>在一些操作系统（类Unix）中，所有的输入/输出设备，包括键盘、显示器、通信链路等，都会提供类似于文件系统的接口，如图 2.19 所示。这样用户只需要与简单的操作函数打交道，而不需要直到具体的实现细节。</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15234562457503.jpg" alt=""></p>
<h2 id="2-4-LOOKING-BACK-AND-AHEAD"><a href="#2-4-LOOKING-BACK-AND-AHEAD" class="headerlink" title="2.4 LOOKING BACK AND AHEAD"></a>2.4 LOOKING BACK AND AHEAD</h2><p>目前已涉及的内容包括：</p>
<ul>
<li>计算机系统设计的三种重要抽象<ul>
<li>存储器</li>
<li>解释器</li>
<li>通信链路</li>
</ul>
</li>
<li>如何将模块抽象的通用模型</li>
<li>计算机系统典型的三层架构</li>
</ul>
<p>下会具体的分析现实中的实现案例。</p>
<h2 id="2-5-CASE-STUDY-UNIX-®️-FILE-SYSTEM-LAYERING-AND-NAMING"><a href="#2-5-CASE-STUDY-UNIX-®️-FILE-SYSTEM-LAYERING-AND-NAMING" class="headerlink" title="2.5 CASE STUDY: UNIX^®️ FILE SYSTEM LAYERING AND NAMING"></a>2.5 CASE STUDY: UNIX^®️ FILE SYSTEM LAYERING AND NAMING</h2><h3 id="2-5-1-Application-Programming-Interface-for-the-UNIX-File-System"><a href="#2-5-1-Application-Programming-Interface-for-the-UNIX-File-System" class="headerlink" title="2.5.1 Application Programming Interface for the UNIX File System"></a>2.5.1 Application Programming Interface for the UNIX File System</h3><p>UNIX文件系统提供的应用编程接口(API)如表 2.1 所示：</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15238003056516.jpg" alt=""></p>
<p>UNIX文件系统通过分治法(Divide-and-conquer)来实现这些API函数，将底层的面向机器(Machine-oriented)的命名，比如地址，通过更上层的抽象隐藏起来，最后实现文件的表述，如表 2.2 所示：</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15238006083283.jpg" alt=""></p>
<h3 id="2-5-2-The-Block-Layer"><a href="#2-5-2-The-Block-Layer" class="headerlink" title="2.5.2 The Block Layer"></a>2.5.2 The Block Layer</h3><p>在UNIX文件系统的底层，文件被分割成大小固定的单元——块(Blocks)存储在非易失性介质里。块是磁盘空间的最小单元，其大小的设定是根据多种因素权衡得到的。</p>
<p>可以用数字编号来命名块，代表了从存储设备最开始到当前块的偏移。其名字和内容的映射关系可以用下面的伪代码表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure BLOCK_NUMBER_TO_BLOCK (integer b) returns block</span><br><span class="line">    return device[b]</span><br></pre></td></tr></table></figure>
<p>文件系统通过超级块(Super block)来记录磁盘的使用情况。现代的UNIX文件系统还会通过位图(Bitmap)来追踪块是否被占用。图 2.2 列举了一种简单文件系统的块结构，其中Inode表中存了每个文件的入口。</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15238869739270.jpg" alt=""></p>
<h3 id="2-5-3-The-File-Layer"><a href="#2-5-3-The-File-Layer" class="headerlink" title="2.5.3 The File Layer"></a>2.5.3 The File Layer</h3><p>为了支持文件大小可以自由的增大和减小，UNIX文件系统提供了新的一层抽象使文件系统可以知道哪些块属于某一个特定的文件。这个记录文件元数据(Metadata)的容器就是索引节点(Index node)，通常称作Inode。Inode的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">structure inode</span><br><span class="line">    integer block_numbers[N]    // the numbers of the blocks that constitute the file</span><br><span class="line">    integer size    // the size of the file in bytes</span><br></pre></td></tr></table></figure>
<p>Inode中块的映射算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure INDEX_TO_BLOCK_NUMBER (inode instance i, integer index) returns integer</span><br><span class="line">    return i.block_numbers[index]</span><br></pre></td></tr></table></figure>
<p>在大文件的映射上，第六版UNIX文件系统采用了间接块(Indirect blocks)的方式，而现代的UNIX系统会用更先进的数据结构来组织文件，比如B+树。</p>
<p>通过Offset和前面的两个函数来获得文件中特定的字节，即块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">procedure INODE_TO_BLOCK (integer offset, inode instance i) returns block</span><br><span class="line">    o &lt;- offset / BLOCKSIZE</span><br><span class="line">    b &lt;- INDEX_TO_BLOCK_NUMBER(i, o)</span><br><span class="line">    return BLOCK_NUMBER_TO_BLOCK(b)</span><br></pre></td></tr></table></figure>
<h3 id="2-5-4-The-Inode-Number-Layer"><a href="#2-5-4-The-Inode-Number-Layer" class="headerlink" title="2.5.4 The Inode Number Layer"></a>2.5.4 The Inode Number Layer</h3><p>UNIX文件系统还提供了一个包含所有Inode的表，用Inode的编号来做索引，下面就是具体的算法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure INODE_NUMBER_TO_INODE(integer inode_number) returns inode</span><br><span class="line">    return inode_table[inode_number]</span><br></pre></td></tr></table></figure>
<p>下面的函数通过<em>offset</em>和<em>inode_number</em>来得到特定的块，块中的内容就是<em>inode_number</em>指向的文件里从<em>offset</em>位置开始的字节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">procedure INODE_NUMBER_TO_BLOCK(integer offset, integer inode_number) returns block</span><br><span class="line">    inode instance i &lt;- INODE_NUMBER_TO_INODE(inode_number)</span><br><span class="line">    o &lt;- offset / BLOCKSIZE</span><br><span class="line">    b &lt;- INDEX_TO_BLOCK_NUMBER(i, o)</span><br><span class="line">    return BLOCK_NUMBER_TO_BLOCK(b)</span><br></pre></td></tr></table></figure>
<h3 id="2-5-5-The-File-Name-Layer"><a href="#2-5-5-The-File-Name-Layer" class="headerlink" title="2.5.5 The File Name Layer"></a>2.5.5 The File Name Layer</h3><p>因为数字对用户来说可读性不高，所以UNIX文件系统增加了一个新的命名层，用来隐藏文件管理中的元数据(Metadata)，其中就包括目录(Directory)，下面展示了如何在目录中检索一个文件的伪代码，如果找到文件的入口就会返回其Inode编号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure NAME_TO_INODE_NUMBER(character string filename, integer dir) returns integer</span><br><span class="line">  return LOOKUP(filename, dir)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">structure inode</span><br><span class="line">    integer block_numbers[N]</span><br><span class="line">    integer size</span><br><span class="line">    integer type // type of file: regular file, directory,...</span><br></pre></td></tr></table></figure>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15239824190641.jpg" alt=""></p>
<h3 id="2-5-6-The-Path-Name-Layer"><a href="#2-5-6-The-Path-Name-Layer" class="headerlink" title="2.5.6 The Path Name Layer"></a>2.5.6 The Path Name Layer</h3><p>路径的算法是通过递归的调用上面的<em>LOOKUP</em>函数实现的：</p>
<p><img src="http://p6ayvlg30.bkt.clouddn.com/15239832305990.jpg" alt=""></p>
<p>其中第二行的<em>PLAIN_NAME</em>会扫描参数中的标准路径分隔符（UNIX中是‘/’），如果没有分隔符就返回<em>TRUE</em>，所以递归的终点就是返回指定路径的Inode编号。</p>
<p><em>CHDIR</em>用来切换工作目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure CHDIR (path character string)</span><br><span class="line">    wd &lt;- PATH_TO_INODE_NUMBER(path, wd)</span><br></pre></td></tr></table></figure>
<h3 id="2-5-7-Links"><a href="#2-5-7-Links" class="headerlink" title="2.5.7 Links"></a>2.5.7 Links</h3><h3 id="2-5-8-Renaming"><a href="#2-5-8-Renaming" class="headerlink" title="2.5.8 Renaming"></a>2.5.8 Renaming</h3><h3 id="2-5-9-The-Absolute-Path-Name-Layer"><a href="#2-5-9-The-Absolute-Path-Name-Layer" class="headerlink" title="2.5.9 The Absolute Path Name Layer"></a>2.5.9 The Absolute Path Name Layer</h3><h3 id="2-5-10-The-Symbolic-Link-Layer"><a href="#2-5-10-The-Symbolic-Link-Layer" class="headerlink" title="2.5.10 The Symbolic Link Layer"></a>2.5.10 The Symbolic Link Layer</h3><h3 id="2-5-11-Implementing-the-File-System-API"><a href="#2-5-11-Implementing-the-File-System-API" class="headerlink" title="2.5.11 Implementing the File System API"></a>2.5.11 Implementing the File System API</h3><h3 id="2-5-12-The-Shell-and-Implied-Context-Search-Paths-and-Name-Discovery"><a href="#2-5-12-The-Shell-and-Implied-Context-Search-Paths-and-Name-Discovery" class="headerlink" title="2.5.12 The Shell and Implied Context, Search Paths, and Name Discovery"></a>2.5.12 The Shell and Implied Context, Search Paths, and Name Discovery</h3><h6 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h6><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://groups.csail.mit.edu/tds/papers/Gilbert/Brewer2.pdf" target="_blank" rel="noopener">Perspectives on the CAP Theorem</a><a href="#fnref:0" rev="footnote"> ↩</a></span></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8" target="_blank" rel="noopener">随机存取存储器</a>（英语：Random Access Memory，RAM），是与CPU直接交换数据的内部存储器，也叫主存。[1]它可以随时读写（刷新时除外，见下文），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/RAID" target="_blank" rel="noopener">独立硬盘冗余阵列（RAID, Redundant Array of Independent Disks）</a>，旧称廉价磁盘冗余阵列（Redundant Array of Inexpensive Disks），简称磁盘阵列。其基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/LISP" target="_blank" rel="noopener">LISP</a>是第一个函数式程序语言，区别于C语言、Fortran等命令型程序语言和Java、C#、Objective-C等面向对象程序语言。<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96" target="_blank" rel="noopener">DMA</a>允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需中央处理器（CPU）介入处理 。<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E5%99%A8%E6%98%A0%E5%B0%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA" target="_blank" rel="noopener">MMIO</a>使用相同的地址总线来寻址内存和输入输出设备（简称IO设备），前提是IO设备上的设备内存和寄存器都已经被映射到内存空间的某个地址。<a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>
      
    </div>

    

    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>夏秋</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://shaqsnake.github.io/2018/04/01/PCSD-02.html" title="Principles of Computer System Design 读书笔记 II">http://shaqsnake.github.io/2018/04/01/PCSD-02.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/读书笔记/" rel="tag"># 读书笔记</a>
          
            <a href="/tags/computer-design/" rel="tag"># computer design</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/27/PCSD-01.html" rel="next" title="Principles of Computer System Design 读书笔记 I">
                <i class="fa fa-chevron-left"></i> Principles of Computer System Design 读书笔记 I
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNTMwMC8xMTgzNg=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="夏秋" />
            
              <p class="site-author-name" itemprop="name">夏秋</p>
              <p class="site-description motion-element" itemprop="description">架构师之路</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/shaqsnake" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:shaqsnake@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CHAPTER-2-Elements-of-Computer-System-Organization"><span class="nav-number">1.</span> <span class="nav-text">CHAPTER 2 Elements of Computer System Organization</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OVERVIEW"><span class="nav-number">1.1.</span> <span class="nav-text">OVERVIEW</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-THE-THREE-FUNDAMENTAL-ABSTRACTIONS"><span class="nav-number">1.2.</span> <span class="nav-text">2.1 THE THREE FUNDAMENTAL ABSTRACTIONS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-Memory"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1.1 Memory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-1-Read-Write-Coherence-and-Atomicity"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">2.1.1.1 Read/Write Coherence and Atomicity</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-2-Memory-Latency"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.1.1.2 Memory Latency</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-3-Memory-Names-and-Addresses"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.1.1.3 Memory Names and Addresses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-4-Exploiting-the-Memory-Abstraction-RAID"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.1.1.4 Exploiting the Memory Abstraction: RAID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-Interpreters"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.1.2 Interpreters</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-1-Processors"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">2.1.2.1 Processors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-2-Interpreter-Layers"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">2.1.2.2 Interpreter Layers</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-Communication-Links"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.1.3 Communication Links</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-NAMING-IN-COMPUTER-SYSTEMS"><span class="nav-number">1.3.</span> <span class="nav-text">2.2 NAMING IN COMPUTER SYSTEMS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-The-Naming-Model"><span class="nav-number">1.3.1.</span> <span class="nav-text">2.2.1 The Naming Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-Default-and-Explicit-Context-References"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.2.2 Default and Explicit Context References</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-Path-Names-Naming-Networks-and-Recursive-Name-Resolution"><span class="nav-number">1.3.3.</span> <span class="nav-text">2.2.3 Path Names, Naming Networks, and Recursive Name Resolution</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-Multiple-Lookup-Searching-through-Layered-Contexts"><span class="nav-number">1.3.4.</span> <span class="nav-text">2.2.4 Multiple Lookup: Searching through Layered Contexts</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-5-Comparing-Names"><span class="nav-number">1.3.5.</span> <span class="nav-text">2.2.5 Comparing Names</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-6-Name-Discovery"><span class="nav-number">1.3.6.</span> <span class="nav-text">2.2.6 Name Discovery</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-ORGANIZING-COMPUTER-SYSTEMS-WITH-NAMES-AND-LAYERS"><span class="nav-number">1.4.</span> <span class="nav-text">2.3 ORGANIZING COMPUTER SYSTEMS WITH NAMES AND LAYERS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-A-Hardware-Layer-The-Bus"><span class="nav-number">1.4.1.</span> <span class="nav-text">2.3.1 A Hardware Layer: The Bus</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-A-Software-Layer-The-File-Abstraction"><span class="nav-number">1.4.2.</span> <span class="nav-text">2.3.2 A Software Layer: The File Abstraction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-LOOKING-BACK-AND-AHEAD"><span class="nav-number">1.5.</span> <span class="nav-text">2.4 LOOKING BACK AND AHEAD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-CASE-STUDY-UNIX-®️-FILE-SYSTEM-LAYERING-AND-NAMING"><span class="nav-number">1.6.</span> <span class="nav-text">2.5 CASE STUDY: UNIX^®️ FILE SYSTEM LAYERING AND NAMING</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-Application-Programming-Interface-for-the-UNIX-File-System"><span class="nav-number">1.6.1.</span> <span class="nav-text">2.5.1 Application Programming Interface for the UNIX File System</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-The-Block-Layer"><span class="nav-number">1.6.2.</span> <span class="nav-text">2.5.2 The Block Layer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-The-File-Layer"><span class="nav-number">1.6.3.</span> <span class="nav-text">2.5.3 The File Layer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-4-The-Inode-Number-Layer"><span class="nav-number">1.6.4.</span> <span class="nav-text">2.5.4 The Inode Number Layer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-5-The-File-Name-Layer"><span class="nav-number">1.6.5.</span> <span class="nav-text">2.5.5 The File Name Layer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-6-The-Path-Name-Layer"><span class="nav-number">1.6.6.</span> <span class="nav-text">2.5.6 The Path Name Layer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-7-Links"><span class="nav-number">1.6.7.</span> <span class="nav-text">2.5.7 Links</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-8-Renaming"><span class="nav-number">1.6.8.</span> <span class="nav-text">2.5.8 Renaming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-9-The-Absolute-Path-Name-Layer"><span class="nav-number">1.6.9.</span> <span class="nav-text">2.5.9 The Absolute Path Name Layer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-10-The-Symbolic-Link-Layer"><span class="nav-number">1.6.10.</span> <span class="nav-text">2.5.10 The Symbolic Link Layer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-11-Implementing-the-File-System-API"><span class="nav-number">1.6.11.</span> <span class="nav-text">2.5.11 Implementing the File System API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-12-The-Shell-and-Implied-Context-Search-Paths-and-Name-Discovery"><span class="nav-number">1.6.12.</span> <span class="nav-text">2.5.12 The Shell and Implied Context, Search Paths, and Name Discovery</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#注释"><span class="nav-number">1.6.12.0.0.1.</span> <span class="nav-text">注释</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate"> 
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">夏秋</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">33k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点总阅读时长">2:44</span>
  
</div>











        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="总访客量">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="总访问量">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.6"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.6"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.6"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.6"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.6"></script>



  



	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  










  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=6.0.6"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("lXbkOuC7GfKvxK8s2idwUN1G-gzGzoHsz", "hPKwBwxTXSIoiv5GSwHwHaMI");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            
            counter.save(null, {
              success: function(counter) {
                
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(counter.get('time'));
                
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! See more at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see here how to solve it: https://github.com/theme-next/hexo-leancloud-counter-security. \n But you also can use LeanCloud without security, by set \'security\' option to \'false\'.');
            
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  

  


  
  

  

  

  

  

</body>
</html>
