<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏秋的博客</title>
  
  <subtitle>Code Monkey&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shaqsnake.github.io/"/>
  <updated>2018-04-19T18:07:50.000Z</updated>
  <id>http://shaqsnake.github.io/</id>
  
  <author>
    <name>夏秋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Principles of Computer System Design 读书笔记 II</title>
    <link href="http://shaqsnake.github.io/2018/04/01/PCSD-02.html"/>
    <id>http://shaqsnake.github.io/2018/04/01/PCSD-02.html</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-04-19T18:07:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="CHAPTER-2-Elements-of-Computer-System-Organization"><a href="#CHAPTER-2-Elements-of-Computer-System-Organization" class="headerlink" title="CHAPTER 2 Elements of Computer System Organization"></a>CHAPTER 2 Elements of Computer System Organization</h1><h2 id="OVERVIEW"><a href="#OVERVIEW" class="headerlink" title="OVERVIEW"></a>OVERVIEW</h2><p>实践中最重要的三个对计算机系统组件的抽象是：</p><ul><li>The memory（存储器）</li><li>The interpreter （解释器）</li><li>The communication link (通信链路）</li></ul><p>设计者运用这三个抽象来组织物理硬件的结构，不仅仅因为它们是直接的通道，还因为：</p><ul><li>它们提供了最基础的函数，包括调用(取值），处理和通信；</li><li>它们也是对硬件最简单，接口最清晰的抽象。</li></ul><p><strong>Reference</strong> - 引用，一种将计算机系统中交互组件抽象的方式。通常一个组件用过特定的命名方式通另一个组件相连。</p><a id="more"></a><h2 id="2-1-THE-THREE-FUNDAMENTAL-ABSTRACTIONS"><a href="#2-1-THE-THREE-FUNDAMENTAL-ABSTRACTIONS" class="headerlink" title="2.1 THE THREE FUNDAMENTAL ABSTRACTIONS"></a>2.1 THE THREE FUNDAMENTAL ABSTRACTIONS</h2><h3 id="2-1-1-Memory"><a href="#2-1-1-Memory" class="headerlink" title="2.1.1 Memory"></a>2.1.1 Memory</h3><p><strong>Memory</strong> - 存储器，是系统在做计算时用来储存数值的组件。</p><p><em>注解：文中的上下文中Memory是更广泛含义的存储，包括内存，文件储存或一些其它的存储形式的总称。</em></p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15221591682350.jpg" alt=""></p><p>虽然图 2.1 列出了许多种存储，但所有的存储都可以被抽象成一个模块，一个包括“<strong>读</strong>”和“<strong>写</strong>”操作的模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WRITE(name, value)</span><br><span class="line">value &lt;- READ(name)</span><br></pre></td></tr></table></figure><p>存储器分为：</p><ul><li>易失性存储器(volatile memory)</li><li>非易失性存储器(non-volatile memory or stable storage)</li></ul><p>硬件层的存储器设备在存储单元上来读写的数据，通常是一段固定长度的bit，比如bytes(8bits)，words(number of bytes, typically 2, 4, 8), lines(several words)和block(a number of bytes, usually a power of 2)。</p><p>高层次的存储器系统也是读写一段连续的bit，但在长度上更灵活，可以是record，segment或者file。</p><h4 id="2-1-1-1-Read-Write-Coherence-and-Atomicity"><a href="#2-1-1-1-Read-Write-Coherence-and-Atomicity" class="headerlink" title="2.1.1.1 Read/Write Coherence and Atomicity"></a>2.1.1.1 Read/Write Coherence and Atomicity</h4><p>存储器有两个特性：</p><ul><li><strong>read/write coherence</strong> - 读写一致性</li><li><strong>before-or-after atomicity</strong> - 前后原子性</li></ul><p>设计者通常为简单地假定这两个特性，但是这种假设是有风险且容易出错的，有许多情况都会威胁到存储器的读写一致性和前后原子性：</p><ul><li><strong>Concurrency</strong> - 并发</li><li><strong>Remote storage</strong> - 远程存储，延迟带来的问题；</li><li><strong>Performance enhancements</strong> - 性能优化，在一些编译器和高性能处理器优化过程中可能会改变操作存储器的顺序，从而破坏读写一致性；</li><li><strong>Cell size incommensurate with value size</strong> - 存储单元与数值大小不匹配，一个非常大的数值可能会占据很多存储单元，而在读写过程中由于只能一次操作一个存储单元，可能会破坏前后原子性。同样在操作小数值时，两个同时对同一存储单元进行的写操作也会破坏原子性。</li><li><strong>Replicated storage</strong> - 分布式（分片）存储。</li></ul><p>系统设计者可能会同时面对上面的多种情况，其中分布式和远程延迟是最具挑战的，有时设计者会设计出弱一致性的存储。<br><em>注解：可参考分布式系统CAP理论<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[Perspectives on the CAP Theorem](https://groups.csail.mit.edu/tds/papers/Gilbert/Brewer2.pdf)">[0]</span></a></sup></em></p><p>最后我们通常会假定物理的存储设备保证了单存储单元的读写一致性，但是对于多存储单元的前后一致性就需要上层的具体实现来保证了。</p><h3 id="2-1-1-2-Memory-Latency"><a href="#2-1-1-2-Memory-Latency" class="headerlink" title="2.1.1.2 Memory Latency"></a>2.1.1.2 Memory Latency</h3><p><strong>Access time / Latency</strong> - 磁盘读或写操作消耗的时间。</p><p><strong>Random access memory(RAM)</strong> - 随机存取存储器<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[随机存取存储器](https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8)（英语：Random Access Memory，RAM），是与CPU直接交换数据的内部存储器，也叫主存。[1]它可以随时读写（刷新时除外，见下文），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。">[1]</span></a></sup></p><p>对于大块数据的<strong>READ</strong>和<strong>WRITE</strong>操作有时又被称为<strong>GET</strong>和<strong>PUT</strong>，传统上<strong>memory</strong>也特指随机存取的易失性存储器，而<strong>storage</strong>指非易失性的存储器，<strong>storage</strong>对大块数据的读写是<strong>GET</strong>（取）和<strong>PUT</strong>（存）。</p><h3 id="2-1-1-3-Memory-Names-and-Addresses"><a href="#2-1-1-3-Memory-Names-and-Addresses" class="headerlink" title="2.1.1.3 Memory Names and Addresses"></a>2.1.1.3 Memory Names and Addresses</h3><p><img src="http://p6ayvlg30.bkt.clouddn.com/15222444178749.jpg" alt=""></p><p>图 2.2 展示了<strong>结合储存(Associativity memory)</strong>的应用架构，通常结合储存位于地址储存的上层，负责高效返回需要经常查询的值。</p><p><em>注解：其实就是我们熟悉的缓存(Cache)</em></p><h3 id="2-1-1-4-Exploiting-the-Memory-Abstraction-RAID"><a href="#2-1-1-4-Exploiting-the-Memory-Abstraction-RAID" class="headerlink" title="2.1.1.4 Exploiting the Memory Abstraction: RAID"></a>2.1.1.4 Exploiting the Memory Abstraction: RAID</h3><p><strong>RAID</strong><sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[独立硬盘冗余阵列（RAID, Redundant Array of Independent Disks）](https://zh.wikipedia.org/wiki/RAID)，旧称廉价磁盘冗余阵列（Redundant Array of Inexpensive Disks），简称磁盘阵列。其基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。">[2]</span></a></sup>的全称是 Redundant Array of Independent(or Inexpensive) Disks，它如图 2.2 所示，由许多磁盘和一个控制器组成，其中控制器的接口同单个磁盘的数据接口是一样的。</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15224131707131.jpg" alt=""></p><p><em>注解：这个图是不是很像负载均衡</em></p><p>RAID控制器会将READ和WRITE的请求通过接口分发到磁盘上。RAID主要作用有两个：</p><ul><li>提高性能，并发的读写磁盘；</li><li>保护数据，多个磁盘有多个数据备份。</li></ul><h3 id="2-1-2-Interpreters"><a href="#2-1-2-Interpreters" class="headerlink" title="2.1.2 Interpreters"></a>2.1.2 Interpreters</h3><p>图 2.4 列举计算机中常见的解释器。</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15224148791780.jpg" alt=""></p><p><strong>Interpreter</strong> - 解释器，包括了三个基本元素：</p><ul><li>指令引用，告诉解释器去哪里寻找下一个指令；</li><li>指令集，定义了解释器将要执行的指令的集合，这些指令通过上面的指令引用来获得；</li><li>环境引用，告诉了解释器哪里去获得相关的环境，环境的状态会影响当期指令的进行的动作。</li></ul><p>图 2.5 是程序运行时解释器的流程图和伪代码，解释器从环境引用里获得当前环境，从指令引用中获得程序指令，然后执行指令，此操作可能会改变环境中的数据，当完成指令后解释器会继续上面的流程执行下一个指令，周而复始。但在这个过程中有一个事件会让解释器停止当前成俗的工作，这就是中断(<strong>Interrupts</strong>)。被中断的程序不在有解释器的控制权，相应地一个新程序会接管解释器，更新指令和环境。</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15224151583737.jpg" alt=""></p><p>许多系统都有不止一个解释器，多解释器通常是异步(<strong>Asynchronous</strong>)工作的，导致即使同一个程序中，解释器的进度都会不一致。正是由于解释器的异步导致内存中的读写一致性和前后原子性变成了设计的一个难点。</p><h4 id="2-1-2-1-Processors"><a href="#2-1-2-1-Processors" class="headerlink" title="2.1.2.1 Processors"></a>2.1.2.1 Processors</h4><p>通常处理器就是一个解释器的具体实现，处理器的指令引用称作程序计数器(<strong>PC - Program Counter</strong>)，存在处理器的高速缓存中。PC中包含了具体指令的内存地址，而环境引用放在了寄存器(<strong>Register</strong>)中。</p><p>处理器的指令集包括了一些计算表达式，不如加(<strong>ADD</strong>)、减(<strong>SUB</strong>)、数据比较(<strong>CMP</strong>)和指令更替(<strong>JMP</strong>)等等，这些指令存储在处理器的寄存器里，有时昵称为“操作代码(<strong>Op-codes</strong>)。</p><p>指令集还包括了许多在寄存器和内存之间移动数据的操作：</p><ul><li>LOAD - 表示寄存器从内存中读取数值；</li><li>STORE - 表示把寄存器里的数值写到内存单元上。</li></ul><p>处理器提供了一个先进后出的数据结构——栈，在内存上实现程序的调用。处理器里有个专门的寄存器来存储栈顶的内存地址(Stack point)。</p><p>最后，处理器还实现了中断，中断可以让处理器检测到运行程序中的问题（比如程序试图执行一个解释器无法执行的指令，比如除零）。中断也可以是因为外部的一些信号，让处理器处理一些更紧急的工作。</p><h4 id="2-1-2-2-Interpreter-Layers"><a href="#2-1-2-2-Interpreter-Layers" class="headerlink" title="2.1.2.2 Interpreter Layers"></a>2.1.2.2 Interpreter Layers</h4><p>解释器通常是用层次结构来描述的，最底层一般包括的是硬件的最基本指令，上面的层次会在此基础上提供一些复杂的指令集，如图 2.6 所示：</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15225942677247.jpg" alt=""></p><p>图 2.7 列举的一个用Java实现的日历程序中指令如何从高层级往低层级转化的过程：</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15225947387759.jpg" alt=""></p><p><em>注解：程序的任务操作或事件都被逐层的翻译给下一层来调用，最后变成硬件能识别的机器语言</em></p><h3 id="2-1-3-Communication-Links"><a href="#2-1-3-Communication-Links" class="headerlink" title="2.1.3 Communication Links"></a>2.1.3 Communication Links</h3><p>图 2.8 列举了一些常见的通信链路的技术，其实就是提供了一种让不同的物理组件能够通信交互的途径。</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15225950877197.jpg" alt=""></p><p>通信链路可以抽象成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEND(link_name, outgoing_message_buffer)</span><br><span class="line">RECEIVE(link_name, incoming_message_buffer)</span><br></pre></td></tr></table></figure><ul><li><strong>SEND</strong>操作指定了具体的通信链路名称(link_name)和需要发送信息内容(message)。</li><li><strong>RECEIVE</strong>操作同样指定了link_name和接受的信息。</li></ul><p><em>注解：因为在内存中字符串内容的通常是以字符串第一个指针和字符串长度来获取的，所以伪代码中用message_buffer来表示message的内容。</em></p><p>虽然看起来数据链路的SEND和RECEIVE很像是从一个内存READ或WRITE到另一个内存的操作，看似不需要再抽象出这一层。但是实际上数据链路传输数据的情况要复杂许多（比如网络错误，发送失败等等），需要实现比READ和WRITE更多的细节，所以数据链路的这层抽象还是很有必要的。</p><h2 id="2-2-NAMING-IN-COMPUTER-SYSTEMS"><a href="#2-2-NAMING-IN-COMPUTER-SYSTEMS" class="headerlink" title="2.2 NAMING IN COMPUTER SYSTEMS"></a>2.2 NAMING IN COMPUTER SYSTEMS</h2><p>在程序函数中调用对象的两种方式：</p><ul><li>获得一个对象的拷贝（值）</li><li>获得一个对象的命名（引用）</li></ul><p>虽然在函数中传递参数时只获取另一对象的值显得更模块化，因为在函数内修改对象的值并不会影响到对象本身，但如果需要这个对象更新的状态被更多的函数感知时，传递值就不行了。所以很多程序都提供了可以共享对象的命名机制。<br><em>注解：即C/C++中的指针，其实很多无指针概念的编程语言在传递对象是也是传递的引用。</em></p><p>解耦两个对象的有效方式就是通过命名来起到中介代理的作用。<br><em>注解：其实就是说在一个对象里需要用到另一个对象时，只要用那个对象的间接引用（C语言里就是指针）就可以了。</em></p><h3 id="2-2-1-The-Naming-Model"><a href="#2-2-1-The-Naming-Model" class="headerlink" title="2.2.1 The Naming Model"></a>2.2.1 The Naming Model</h3><p>命名体系的三要素：</p><ul><li><strong>Name Space</strong> - 命名空间</li><li><strong>Name-mapping algorithm</strong> - 命名映射算法</li><li><strong>Universe of values</strong> - 值域</li></ul><p><img src="http://p6ayvlg30.bkt.clouddn.com/15227672437883.jpg" alt=""></p><p>如图 2.10，其中命名映射是更根据上下文(Context)来切换的，具体操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value &lt;- RESOLVE(name, context)</span><br></pre></td></tr></table></figure><p>除此之外，还有另外四个操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">status &lt;- BIND(name, value, context)</span><br><span class="line">status &lt;- UNBIND(name, context)</span><br><span class="line">list &lt;- ENUMERATE(context)</span><br><span class="line">result &lt;- COMPARE(name1, name2)</span><br></pre></td></tr></table></figure><p>第一个操作<strong>BIND</strong>是在特定上下文中为一个命名绑定了一个新值，stauts是执行的状态（是否成功），第二个操作<strong>UNBIND</strong>就是解绑，status同第一个操作。<strong>ENUMERATE</strong>就是列举出当前Context中的所有已被绑定的值。最后<strong>COMPARE</strong>是用来判断两个命名所绑定的值是否相等的。</p><p>三种常见的命名映射算法：</p><ul><li><strong>Table lookup</strong> - 表查找</li><li><strong>Recursive lookup</strong> - 递归查找</li><li><strong>Multiple lookup</strong> - 重复查找</li></ul><h3 id="2-2-2-Default-and-Explicit-Context-References"><a href="#2-2-2-Default-and-Explicit-Context-References" class="headerlink" title="2.2.2 Default and Explicit Context References"></a>2.2.2 Default and Explicit Context References</h3><p>当程序解释器遇到一个对象时，需要上下文的引用得到具体的命名映射算法，然后才能通过对象名来进行解析。上下文的引用有两类：</p><ul><li><strong>Default</strong> - 默认的</li><li><strong>Explicit</strong> - 显式的</li></ul><p>默认的解析器是由解析器提供的，而显示的解析器是由对象所提供，如图 2.12。</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15228632272684.jpg" alt=""></p><p><em>注解：图2.12 中显示引用的第二种形式是限定名(qualified name)，现实中的像特定对象的属性(N.x)或XML格式的命名(<xml>X</xml>)都可以认为是限定名。</em></p><h3 id="2-2-3-Path-Names-Naming-Networks-and-Recursive-Name-Resolution"><a href="#2-2-3-Path-Names-Naming-Networks-and-Recursive-Name-Resolution" class="headerlink" title="2.2.3 Path Names, Naming Networks, and Recursive Name Resolution"></a>2.2.3 Path Names, Naming Networks, and Recursive Name Resolution</h3><p><img src="http://p6ayvlg30.bkt.clouddn.com/15228650610668.jpg" alt=""></p><p>上图都是一些路径名的例子，它们都包含了多层组件名字。解析路径时我们需要不断重复的去识别出命名中最小区别的步部分，比如：</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15228652746718.jpg" alt=""></p><p>路径名中常见的一些概念：</p><ul><li><strong>root</strong> - 根路径</li><li><strong>Absolute path name</strong> - 绝对路径</li><li><strong>Relative path name</strong> - 相对路径</li><li><strong>Synonyms/Aliases</strong> - 别名</li><li><strong>Links</strong> - 链接</li></ul><h3 id="2-2-4-Multiple-Lookup-Searching-through-Layered-Contexts"><a href="#2-2-4-Multiple-Lookup-Searching-through-Layered-Contexts" class="headerlink" title="2.2.4 Multiple Lookup: Searching through Layered Contexts"></a>2.2.4 Multiple Lookup: Searching through Layered Contexts</h3><p>当对象被绑定到多个上下文中，解析对象时需要系统地从不同的上下文中来寻找时，就要用到重复查找，常见的有：</p><ul><li><strong>Search path</strong> - 查找路径，常用在编程时进行设置，方便编译器去寻找库文件。</li></ul><p><em>注解：Shell环境中配置的SEARCH_PATH</em></p><h3 id="2-2-5-Comparing-Names"><a href="#2-2-5-Comparing-Names" class="headerlink" title="2.2.5 Comparing Names"></a>2.2.5 Comparing Names</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result &lt;- COMPARE(name1, name2)</span><br></pre></td></tr></table></figure><p>其中result是一个布尔值，True（真）或False（假）。不同的编程语言会提供不同层级的比较，比如两个name的命名是否一致，两个name的值师傅一致，两个name在底层的存储位置是否一致等，比如像LISP<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[LISP](https://zh.wikipedia.org/wiki/LISP)是第一个函数式程序语言，区别于C语言、Fortran等命令型程序语言和Java、C#、Objective-C等面向对象程序语言。">[3]</span></a></sup>语言就提供了三种不同的比较语法 —— EQ（比较参数的名字）、EQU（比较参数的值）、EQUALS（比较整个数据结构）。</p><h3 id="2-2-6-Name-Discovery"><a href="#2-2-6-Name-Discovery" class="headerlink" title="2.2.6 Name Discovery"></a>2.2.6 Name Discovery</h3><p>命名发现的两个要素：</p><ul><li>提供者能表现(Advertise)名字的存在感</li><li>使用者能搜索(Search)合适的关键字</li></ul><h2 id="2-3-ORGANIZING-COMPUTER-SYSTEMS-WITH-NAMES-AND-LAYERS"><a href="#2-3-ORGANIZING-COMPUTER-SYSTEMS-WITH-NAMES-AND-LAYERS" class="headerlink" title="2.3 ORGANIZING COMPUTER SYSTEMS WITH NAMES AND LAYERS"></a>2.3 ORGANIZING COMPUTER SYSTEMS WITH NAMES AND LAYERS</h2><p>图 2.16 展示了一个典型而清晰的计算机三层架构，最底层是硬件组件例如处理器、内存和通信链路等，中间层是操作系统，提供了应用可编程接口(API)，最上层是一些具体的应用程序，如文字处理工具，游戏或网页浏览器等。其中每一层内部也是由层次结构组织起来的。</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15232871548588.jpg" alt=""></p><p>软件和硬件实际上可以相互实现对方的大部分功能，所以在的工程设计上就是一种取舍(Trade-off)的结果，主要考量包括了性能，灵活性，易用性等等。</p><p>可以发现操作系统层次有一种有意思的现象称为层次跳跃(layer bypass)，就是操作系统只隐藏了底层硬件一部分的高危指令，所以高层次的应用程序实际上可以绕过操作系统去调用硬件的另一部分较安全的指令。</p><h3 id="2-3-1-A-Hardware-Layer-The-Bus"><a href="#2-3-1-A-Hardware-Layer-The-Bus" class="headerlink" title="2.3.1 A Hardware Layer: The Bus"></a>2.3.1 A Hardware Layer: The Bus</h3><p>硬件层的实现就包括了本文最开始提到的三种基本抽象，如图 2.17 所示：</p><ul><li>解释器 —— 处理器解释程序</li><li>存储器 —— 内存存储程序和数据</li><li>通信链路 —— I/O设备和外界交互</li></ul><p><img src="http://p6ayvlg30.bkt.clouddn.com/15233660002452.jpg" alt=""></p><p>多个组件都会接到<strong>总线(Bus)</strong>上，以实现高速的信息传递。总线的基本特征包括：</p><ul><li><strong>总线接口(Bus Interface)</strong>连接各种组件的地址线，数据线和控制线；</li><li><strong>总线仲裁协议(Bus Arbitration Protocol)</strong>限制了组件的行为，即在什么时候可以发送和接受信息，使同一时刻内的信号不会产生混乱；</li><li><strong>广播(Broadcast)</strong>保证了连上总线的组件可以接受到每条消息，<strong>总线地址(Bus Address)</strong>保证了特定的消息可以发送给特定的组件。</li></ul><p>一种常见的总线设计方法被称为<strong>拆分事务(Split-transaction)</strong>。</p><p><em>注解：就是把一个完整的操作周期拆分成两个子过程，比如IO读写请求中“主设备请求-&gt;从设备发送-&gt;主设备接受”就被拆分成了“主设备请求-&gt;从设备确认“和“从设备准备发送-&gt;主设备接收“两个阶段的事务，这样在两个事务中间总线的资源可以释放出来被其它设备使用。这个原理和并发中IO的多路复用类似。</em></p><p>两个提高总线效率的技术：</p><ul><li><strong>直接内存访问(Direct Memory Access, DMA)</strong><sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[DMA](https://zh.wikipedia.org/wiki/直接記憶體存取)允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需中央处理器（CPU）介入处理 。">[4]</span></a></sup></li><li><strong>内存映射IO(Memory-mapped I/O, MMIO)</strong><sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[MMIO](https://zh.wikipedia.org/wiki/存储器映射输入输出)使用相同的地址总线来寻址内存和输入输出设备（简称IO设备），前提是IO设备上的设备内存和寄存器都已经被映射到内存空间的某个地址。">[5]</span></a></sup></li></ul><blockquote><p>The principle of least astonishment<br>People are part of the system. The design should match the user’s experience, expectations, and mental models.</p></blockquote><p><em>注解：在计算机系统设计时，要让系统易设置，易使用，易编程，易维护。</em></p><h3 id="2-3-2-A-Software-Layer-The-File-Abstraction"><a href="#2-3-2-A-Software-Layer-The-File-Abstraction" class="headerlink" title="2.3.2 A Software Layer: The File Abstraction"></a>2.3.2 A Software Layer: The File Abstraction</h3><p>计算机系统中文件的两个特性：</p><ul><li>持久性(Durable)，可以长期保持在介质中；</li><li>实名性(Name)，可以通过文件名来共享。</li></ul><p>图 2.18 展示了一个应用如何从键盘读取输入，把输入写到文件中以及如歌在显示设备上显示出来的伪代码：</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15234554384088.jpg" alt=""></p><p>一个典型的文件系统API包括了<strong>打开(OPEN)</strong>文件，<strong>读写(READ/WRITE)</strong>文件和<strong>关闭(CLOSE)</strong>文件的操作。</p><p>OPEN的主要任务包括:</p><ul><li>给文件创建一个临时的引用名，方便后续READ和WRITE操作；</li><li>检查用户是否有权限操作文件；</li><li>在文件内容的最开始设置一个游标(Cursor)或文件指针(File Pointer)来记录文件内容的位移(Offset)情况。</li></ul><p>READ和WRITE根据游标位置和指定的长度来操作读写内容，循环往复把内容读或写到Buf中，一直到文件的末尾才停止。其中写操作也可能会因为存储容量不足而中断。</p><p>CLOSE操作释放文件中的所有状态，包括引用名和游标，有些系统会在CLOSE时保证所有对文件的修改都会保存到非易失性存储设备中，有些系统则会在CLOSE后在后台完成这个动作。</p><p>现今的文件系统会通过OPEN和CLOSE来标记原子操作的开始和结束，保证：</p><ol><li>文件系统可以保证并发访问文件时的一致性，比如一个程序在OPEN文件时如果另一个程序想OPEN这个文件，文件系统可以让第二个程序处于等待状态，直到第一个文件CLOSE这个文件。这种一致性的行为又称作<strong>前后原子性(Before-or-after Atomicity)</strong>。</li><li>如果文件系统在应用CLOSE文件前宕机了，之前的WRITE操作都不会反映到文件中；如果文件系统在应用CLOSE文件后宕机，所有的WRITE操作都会反映到文件中。这种一致性称为<strong>无中间状态原子性(All-or-nothin Atomicity)</strong></li></ol><p>在一些操作系统（类Unix）中，所有的输入/输出设备，包括键盘、显示器、通信链路等，都会提供类似于文件系统的接口，如图 2.19 所示。这样用户只需要与简单的操作函数打交道，而不需要直到具体的实现细节。</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15234562457503.jpg" alt=""></p><h2 id="2-4-LOOKING-BACK-AND-AHEAD"><a href="#2-4-LOOKING-BACK-AND-AHEAD" class="headerlink" title="2.4 LOOKING BACK AND AHEAD"></a>2.4 LOOKING BACK AND AHEAD</h2><p>目前已涉及的内容包括：</p><ul><li>计算机系统设计的三种重要抽象<ul><li>存储器</li><li>解释器</li><li>通信链路</li></ul></li><li>如何将模块抽象的通用模型</li><li>计算机系统典型的三层架构</li></ul><p>下会具体的分析现实中的实现案例。</p><h2 id="2-5-CASE-STUDY-UNIX-®️-FILE-SYSTEM-LAYERING-AND-NAMING"><a href="#2-5-CASE-STUDY-UNIX-®️-FILE-SYSTEM-LAYERING-AND-NAMING" class="headerlink" title="2.5 CASE STUDY: UNIX^®️ FILE SYSTEM LAYERING AND NAMING"></a>2.5 CASE STUDY: UNIX^®️ FILE SYSTEM LAYERING AND NAMING</h2><h3 id="2-5-1-Application-Programming-Interface-for-the-UNIX-File-System"><a href="#2-5-1-Application-Programming-Interface-for-the-UNIX-File-System" class="headerlink" title="2.5.1 Application Programming Interface for the UNIX File System"></a>2.5.1 Application Programming Interface for the UNIX File System</h3><p>UNIX文件系统提供的应用编程接口(API)如表 2.1 所示：</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15238003056516.jpg" alt=""></p><p>UNIX文件系统通过分治法(Divide-and-conquer)来实现这些API函数，将底层的面向机器(Machine-oriented)的命名，比如地址，通过更上层的抽象隐藏起来，最后实现文件的表述，如表 2.2 所示：</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15238006083283.jpg" alt=""></p><h3 id="2-5-2-The-Block-Layer"><a href="#2-5-2-The-Block-Layer" class="headerlink" title="2.5.2 The Block Layer"></a>2.5.2 The Block Layer</h3><p>在UNIX文件系统的底层，文件被分割成大小固定的单元——块(Blocks)存储在非易失性介质里。块是磁盘空间的最小单元，其大小的设定是根据多种因素权衡得到的。</p><p>可以用数字编号来命名块，代表了从存储设备最开始到当前块的偏移。其名字和内容的映射关系可以用下面的伪代码表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure BLOCK_NUMBER_TO_BLOCK (integer b) returns block</span><br><span class="line">    return device[b]</span><br></pre></td></tr></table></figure><p>文件系统通过超级块(Super block)来记录磁盘的使用情况。现代的UNIX文件系统还会通过位图(Bitmap)来追踪块是否被占用。图 2.2 列举了一种简单文件系统的块结构，其中Inode表中存了每个文件的入口。</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15238869739270.jpg" alt=""></p><h3 id="2-5-3-The-File-Layer"><a href="#2-5-3-The-File-Layer" class="headerlink" title="2.5.3 The File Layer"></a>2.5.3 The File Layer</h3><p>为了支持文件大小可以自由的增大和减小，UNIX文件系统提供了新的一层抽象使文件系统可以知道哪些块属于某一个特定的文件。这个记录文件元数据(Metadata)的容器就是索引节点(Index node)，通常称作Inode。Inode的定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">structure inode</span><br><span class="line">    integer block_numbers[N]    // the numbers of the blocks that constitute the file</span><br><span class="line">    integer size    // the size of the file in bytes</span><br></pre></td></tr></table></figure><p>Inode中块的映射算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure INDEX_TO_BLOCK_NUMBER (inode instance i, integer index) returns integer</span><br><span class="line">    return i.block_numbers[index]</span><br></pre></td></tr></table></figure><p>在大文件的映射上，第六版UNIX文件系统采用了间接块(Indirect blocks)的方式，而现代的UNIX系统会用更先进的数据结构来组织文件，比如B+树。</p><p>通过Offset和前面的两个函数来获得文件中特定的字节，即块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">procedure INODE_TO_BLOCK (integer offset, inode instance i) returns block</span><br><span class="line">    o &lt;- offset / BLOCKSIZE</span><br><span class="line">    b &lt;- INDEX_TO_BLOCK_NUMBER(i, o)</span><br><span class="line">    return BLOCK_NUMBER_TO_BLOCK(b)</span><br></pre></td></tr></table></figure><h3 id="2-5-4-The-Inode-Number-Layer"><a href="#2-5-4-The-Inode-Number-Layer" class="headerlink" title="2.5.4 The Inode Number Layer"></a>2.5.4 The Inode Number Layer</h3><p>UNIX文件系统还提供了一个包含所有Inode的表，用Inode的编号来做索引，下面就是具体的算法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure INODE_NUMBER_TO_INODE(integer inode_number) returns inode</span><br><span class="line">    return inode_table[inode_number]</span><br></pre></td></tr></table></figure><p>下面的函数通过<em>offset</em>和<em>inode_number</em>来得到特定的块，块中的内容就是<em>inode_number</em>指向的文件里从<em>offset</em>位置开始的字节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">procedure INODE_NUMBER_TO_BLOCK(integer offset, integer inode_number) returns block</span><br><span class="line">    inode instance i &lt;- INODE_NUMBER_TO_INODE(inode_number)</span><br><span class="line">    o &lt;- offset / BLOCKSIZE</span><br><span class="line">    b &lt;- INDEX_TO_BLOCK_NUMBER(i, o)</span><br><span class="line">    return BLOCK_NUMBER_TO_BLOCK(b)</span><br></pre></td></tr></table></figure><h3 id="2-5-5-The-File-Name-Layer"><a href="#2-5-5-The-File-Name-Layer" class="headerlink" title="2.5.5 The File Name Layer"></a>2.5.5 The File Name Layer</h3><p>因为数字对用户来说可读性不高，所以UNIX文件系统增加了一个新的命名层，用来隐藏文件管理中的元数据(Metadata)，其中就包括目录(Directory)，下面展示了如何在目录中检索一个文件的伪代码，如果找到文件的入口就会返回其Inode编号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure NAME_TO_INODE_NUMBER(character string filename, integer dir) returns integer</span><br><span class="line">  return LOOKUP(filename, dir)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">structure inode</span><br><span class="line">    integer block_numbers[N]</span><br><span class="line">    integer size</span><br><span class="line">    integer type // type of file: regular file, directory,...</span><br></pre></td></tr></table></figure><p><img src="http://p6ayvlg30.bkt.clouddn.com/15239824190641.jpg" alt=""></p><h3 id="2-5-6-The-Path-Name-Layer"><a href="#2-5-6-The-Path-Name-Layer" class="headerlink" title="2.5.6 The Path Name Layer"></a>2.5.6 The Path Name Layer</h3><p>路径的算法是通过递归的调用上面的<em>LOOKUP</em>函数实现的：</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/15239832305990.jpg" alt=""></p><p>其中第二行的<em>PLAIN_NAME</em>会扫描参数中的标准路径分隔符（UNIX中是‘/’），如果没有分隔符就返回<em>TRUE</em>，所以递归的终点就是返回指定路径的Inode编号。</p><p><em>CHDIR</em>用来切换工作目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">procedure CHDIR (path character string)</span><br><span class="line">    wd &lt;- PATH_TO_INODE_NUMBER(path, wd)</span><br></pre></td></tr></table></figure><h3 id="2-5-7-Links"><a href="#2-5-7-Links" class="headerlink" title="2.5.7 Links"></a>2.5.7 Links</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LINK(from_name, to_name)</span><br><span class="line">UNLINK(filename)</span><br></pre></td></tr></table></figure><p>因为有了链接，所以只有在文件所有绑定都被移除的情况下，UNIX文件系统才会删除这个文件。所以需要在Inode中记录引用的次数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">structure inode</span><br><span class="line">  integer block_numbers[N]</span><br><span class="line">  integer size</span><br><span class="line">  integer type</span><br><span class="line">  integer refcnt</span><br></pre></td></tr></table></figure><p>其中“<strong>.</strong>”和“<strong>..</strong>”是两个特殊的链接，代表当前目录和上级目录。</p><h3 id="2-5-8-Renaming"><a href="#2-5-8-Renaming" class="headerlink" title="2.5.8 Renaming"></a>2.5.8 Renaming</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LINK(from_name, to_name)</span><br><span class="line">UNLINK(from_name)</span><br></pre></td></tr></table></figure><p></p><h3 id="2-5-9-The-Absolute-Path-Name-Layer"><a href="#2-5-9-The-Absolute-Path-Name-Layer" class="headerlink" title="2.5.9 The Absolute Path Name Layer"></a>2.5.9 The Absolute Path Name Layer</h3><p><img src="http://p6ayvlg30.bkt.clouddn.com/15241612194585.jpg" alt=""></p><h3 id="2-5-10-The-Symbolic-Link-Layer"><a href="#2-5-10-The-Symbolic-Link-Layer" class="headerlink" title="2.5.10 The Symbolic Link Layer"></a>2.5.10 The Symbolic Link Layer</h3><h3 id="2-5-11-Implementing-the-File-System-API"><a href="#2-5-11-Implementing-the-File-System-API" class="headerlink" title="2.5.11 Implementing the File System API"></a>2.5.11 Implementing the File System API</h3><h3 id="2-5-12-The-Shell-and-Implied-Context-Search-Paths-and-Name-Discovery"><a href="#2-5-12-The-Shell-and-Implied-Context-Search-Paths-and-Name-Discovery" class="headerlink" title="2.5.12 The Shell and Implied Context, Search Paths, and Name Discovery"></a>2.5.12 The Shell and Implied Context, Search Paths, and Name Discovery</h3><h6 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h6><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://groups.csail.mit.edu/tds/papers/Gilbert/Brewer2.pdf" target="_blank" rel="noopener">Perspectives on the CAP Theorem</a><a href="#fnref:0" rev="footnote"> ↩</a></span></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8" target="_blank" rel="noopener">随机存取存储器</a>（英语：Random Access Memory，RAM），是与CPU直接交换数据的内部存储器，也叫主存。[1]它可以随时读写（刷新时除外，见下文），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/RAID" target="_blank" rel="noopener">独立硬盘冗余阵列（RAID, Redundant Array of Independent Disks）</a>，旧称廉价磁盘冗余阵列（Redundant Array of Inexpensive Disks），简称磁盘阵列。其基本思想就是把多个相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、容量巨大的硬盘。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/LISP" target="_blank" rel="noopener">LISP</a>是第一个函数式程序语言，区别于C语言、Fortran等命令型程序语言和Java、C#、Objective-C等面向对象程序语言。<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E8%A8%98%E6%86%B6%E9%AB%94%E5%AD%98%E5%8F%96" target="_blank" rel="noopener">DMA</a>允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，而不需中央处理器（CPU）介入处理 。<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E5%AD%98%E5%82%A8%E5%99%A8%E6%98%A0%E5%B0%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA" target="_blank" rel="noopener">MMIO</a>使用相同的地址总线来寻址内存和输入输出设备（简称IO设备），前提是IO设备上的设备内存和寄存器都已经被映射到内存空间的某个地址。<a href="#fnref:5" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CHAPTER-2-Elements-of-Computer-System-Organization&quot;&gt;&lt;a href=&quot;#CHAPTER-2-Elements-of-Computer-System-Organization&quot; class=&quot;headerlink&quot; title=&quot;CHAPTER 2 Elements of Computer System Organization&quot;&gt;&lt;/a&gt;CHAPTER 2 Elements of Computer System Organization&lt;/h1&gt;&lt;h2 id=&quot;OVERVIEW&quot;&gt;&lt;a href=&quot;#OVERVIEW&quot; class=&quot;headerlink&quot; title=&quot;OVERVIEW&quot;&gt;&lt;/a&gt;OVERVIEW&lt;/h2&gt;&lt;p&gt;实践中最重要的三个对计算机系统组件的抽象是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The memory（存储器）&lt;/li&gt;
&lt;li&gt;The interpreter （解释器）&lt;/li&gt;
&lt;li&gt;The communication link (通信链路）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计者运用这三个抽象来组织物理硬件的结构，不仅仅因为它们是直接的通道，还因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它们提供了最基础的函数，包括调用(取值），处理和通信；&lt;/li&gt;
&lt;li&gt;它们也是对硬件最简单，接口最清晰的抽象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Reference&lt;/strong&gt; - 引用，一种将计算机系统中交互组件抽象的方式。通常一个组件用过特定的命名方式通另一个组件相连。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shaqsnake.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="computer design" scheme="http://shaqsnake.github.io/tags/computer-design/"/>
    
  </entry>
  
  <entry>
    <title>Principles of Computer System Design 读书笔记 I</title>
    <link href="http://shaqsnake.github.io/2018/03/27/PCSD-01.html"/>
    <id>http://shaqsnake.github.io/2018/03/27/PCSD-01.html</id>
    <published>2018-03-26T16:00:00.000Z</published>
    <updated>2018-04-11T14:13:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="CHARPTER-1-Systems"><a href="#CHARPTER-1-Systems" class="headerlink" title="CHARPTER 1 Systems"></a>CHARPTER 1 Systems</h1><h2 id="OVERVIEW"><a href="#OVERVIEW" class="headerlink" title="OVERVIEW"></a>OVERVIEW</h2><p>系统设计者需要有一个全局的、整体的计算机系统观（包括软件方面和硬件方面的）。<br>许多有价值的计算机应用程序都具备：</p><ul><li>容错性</li><li>并发一致性</li><li>离散数据的关联性</li><li>信息的多样性</li><li>对错误和内部攻击的保护性</li><li>与许多用户的交互性</li></ul><p>计算机系统设计的问题同样可以参考许多其它领域的设计问题，因为他们都有一定的共性。<br><strong>System design principles</strong> - 一种可以帮助系统设计者避免犯错的规则，指导或者经验，并不是不能违背的条例。</p><blockquote><p><strong>Avoid excessive generality</strong><br>If it’s good for everything, it’s good for nothing.</p></blockquote><p><em>注解：系统设计的精髓——Everything is Tradeoff。</em></p><a id="more"></a><h2 id="1-1-SYSTEMS-AND-COMPLEXITY"><a href="#1-1-SYSTEMS-AND-COMPLEXITY" class="headerlink" title="1.1 SYSTEMS AND COMPLEXITY"></a>1.1 SYSTEMS AND COMPLEXITY</h2><h3 id="1-1-1-Common-Problems-of-Systems-in-Many-Fields"><a href="#1-1-1-Common-Problems-of-Systems-in-Many-Fields" class="headerlink" title="1.1.1 Common Problems of Systems in Many Fields"></a>1.1.1 Common Problems of Systems in Many Fields</h3><p>各式各样的系统所面临的首要问题主要包括四类：</p><ul><li>Emergent properties（隐性的特征）</li><li>Propagation of effects（效应的传播）</li><li>Incommensurate scaling（不相称的扩长<sup id="fnref:0"><a href="#fn:0" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[Scalability](https://en.wikipedia.org/wiki/Scalability) 和 Scaling 在计算机术语中都是特指系统在所运行所需的资源增加或减少的同时，系统性能可以成比例的增加或降低的可扩展性或伸缩性。但这里用“扩长”更能表达原文的本意。">[0]</span></a></sup>）</li><li>Trade-offs（权衡、取舍）</li></ul><h4 id="1-1-1-1-Emergent-Properties"><a href="#1-1-1-1-Emergent-Properties" class="headerlink" title="1.1.1.1 Emergent Properties"></a>1.1.1.1 Emergent Properties</h4><p><strong>Emergent properties</strong> - 那些平时系统中单个组件内并不明显，但当组件进行组合后却能突然显现的属性或特征。</p><h4 id="1-1-1-2-Propagation-of-Effects"><a href="#1-1-1-2-Propagation-of-Effects" class="headerlink" title="1.1.1.2 Propagation of Effects"></a>1.1.1.2 Propagation of Effects</h4><p><strong>Propagation of Effects</strong> - 系统一端看似很小的改动或异常却造成了系统远端另一部分的破坏。<br><em>注解：类似蝴蝶效应 <sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[蝴蝶效应](https://zh.wikipedia.org/wiki/%E8%9D%B4%E8%9D%B6%E6%95%88%E5%BA%94) (Butterfly effect)是指在一个动态系统中，初始条件下微小的变化能带动整个系统的长期的巨大的连锁反应，是一种混沌的现象。“蝴蝶效应”在混沌学中也常出现。">[1]</span></a></sup>。</em></p><p>所以在绝大多数系统中一个重要的原则就是药尽量限制住系统错误带来的冲击。</p><h4 id="1-1-1-3-Incommensurate-Scaling"><a href="#1-1-1-3-Incommensurate-Scaling" class="headerlink" title="1.1.1.3 Incommensurate Scaling"></a>1.1.1.3 Incommensurate Scaling</h4><p><strong>Incommensurate Scaling</strong> - 当系统在体积或速度上扩大时，并非系统的所有部分都会成比例的增长，最终系统会停止运作。<br><em>注解：就是事物中每个部分的增长或缩小的速率都是不一样的，在自然界和生活中很容易找到相关的例子。</em></p><h4 id="1-1-1-4-Trade-offs"><a href="#1-1-1-4-Trade-offs" class="headerlink" title="1.1.1.4 Trade-offs"></a>1.1.1.4 Trade-offs</h4><p><strong>Trade-offs</strong> - 现实中有利的因素总是有限的，所以设计中的挑战就是首先最大化这些有利因素，避免浪费他们，最后把他们放在最能提升系统的地方。</p><p><strong>Waterbed effect</strong> - 水床效应，即你在处理某些问题时按下去一个问题，另一个问题又会浮现出来。文中列举了芯片设计中最关键的“性能-功耗-面积”问题<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="芯片设计时往往要权衡性能（频率越高性能越好）、功耗（低功耗，特别是手机或便携设备），面积（芯片的制造成本）三者之间的关系，达到最优的结果。">[2]</span></a></sup>。</p><p><strong>Binary classification</strong> - 在分类问题上，我们有时因为无法通过一个显现的属性或特征来区分出两个类别的事物，只能通过降低容错性来提升划分的准确性。<br><em>注解：机器学习中的分类问题也类似。</em></p><p>计算机系统设计还是一个很年轻的领域，并不像一些传统的领域如桥梁或建筑设计那样成熟，所以无法给出一些严格的规格一些或者精准的权衡条件来构造组合系统，只能通过一些特定（ad hoc）案列结合实际情况来分析。<br><em>注解：计算机系统很复杂，很多系统之间找不到一个通用的模型或设计理论，现实开发中的方法论也各不相同，比如大型的复杂项目会倾向于螺旋模型<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[螺旋模型](https://zh.wikipedia.org/wiki/%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B)是一种演化软件开发过程模型，它兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。">[3]</span></a></sup>，而一些小型的互联网项目却选择更容易迭代的敏捷模型<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[敏捷软件开发](https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91)，又称敏捷开发，是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。">[4]</span></a></sup>。</em></p><h3 id="1-1-2-Systems-Components-Interfaces-and-Environments"><a href="#1-1-2-Systems-Components-Interfaces-and-Environments" class="headerlink" title="1.1.2 Systems, Components, Interfaces, and Environments"></a>1.1.2 Systems, Components, Interfaces, and Environments</h3><blockquote><p>A system is a set of interconnected components that has an expected behavior observed at the interface with its enviornment.</p></blockquote><p>一个系统是一些相互交互的组件的集合，这些组件通过特定的接口与和其环境进行交互，且他们间的交互能产生一些特定的可被观察到的行为。<br><em>注解：和系统有交互但并不属于系统本身的就是环境。</em></p><p>对同一套事物用不同的角度去观察可以得到完全不同的系统，这样他们所包含的组件、接口和环境也是不相同的。这时一个系统中的一个组件在某些情景下很可能是另外一个完整的系统。<br><em>注解：比如汽车中发动机只是汽车整系统的一个组件，但在另一些研究发动机系统的情景下它就是一个完整的发动机系统。</em></p><p><strong>Subsystem</strong> - 子系统，当一个系统在特定情境下是另一个系统的组件。</p><p><strong>computer system</strong> or <strong>information system</strong> - 一个能自动控制存储、处理和信息交互的系统，比如：</p><ul><li>一个台个人电脑</li><li>汽车中的动力控制器</li><li>电话系统</li><li>互联网</li><li>飞机票订购系统</li><li>宇宙飞船着陆控制系统</li><li>一个万维网网站</li></ul><h3 id="1-1-3-Complexity"><a href="#1-1-3-Complexity" class="headerlink" title="1.1.3 Complexity"></a>1.1.3 Complexity</h3><p>复杂虽然就暗指“难以理解”，但并没有一种精确的方法来测量系统的复杂度，也没有一个准确的定义来描述复杂度，只能通过一些模糊的特征，比如：</p><ol><li>包含大量的组件；</li><li>拥有大量的交互；</li><li>展现出许多的无规律性；</li><li>冗长的自我描述；</li><li>需要许多设计者、实现者或维护者来工作。</li></ol><p>文中举了一个小镇图书馆和一个大学图书馆的例子来说明了上面五个特征。</p><h2 id="1-2-SOURCES-OF-COMPLEXITY"><a href="#1-2-SOURCES-OF-COMPLEXITY" class="headerlink" title="1.2 SOURCES OF COMPLEXITY"></a>1.2 SOURCES OF COMPLEXITY</h2><p>复杂性的根源主要有两个：</p><ul><li>设计者要系统满足太多的需求；</li><li>需要让系统维持在一个高效的使用效率。</li></ul><h3 id="1-2-1-Cascading-and-Interacting-Requirements"><a href="#1-2-1-Cascading-and-Interacting-Requirements" class="headerlink" title="1.2.1 Cascading and Interacting Requirements"></a>1.2.1 Cascading and Interacting Requirements</h3><blockquote><p><strong>Principle of escalating complexity</strong><br>Adding a requirement increases complexity out of proportion.</p></blockquote><p>图 1.1 展现了复杂度随着需求的增加而呈现出指数级增长的趋势。</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/屏幕快照 2018-03-24 下午11.44.40.png" alt=""></p><p>图中最重要的一点是复杂度的边界是模糊的：当你往系统里添加各种功能和需求时，并没有一个明确的边界提示你应该停下来了。</p><p><strong>Generality</strong> - 通用性，即指用一个单一的系统去满足各种不同的需求，也可以认为去“适应各种多变的环境”。</p><p>要求系统通用往往是造成复杂性的原因之一，设计者这时就需要去权衡和判断到底需要满足多少程度的通用性。</p><blockquote><p><strong>Avoid excessive generality</strong><br>If it is good for everything, it is good for nothing.</p></blockquote><p>不过有一些特例就是要巧妙的把子系统设计得更通用化来让异常降到最低。</p><p>复杂性的另一个原因就是之前提到的不相称的扩长。</p><p>最后，造成复杂性的主要原因就是需求的变化，比如要求系统中的组件进行升级等。系统设计者不可能预测到未来系统的各种变化，当一些未预测到的需求出现时，就给系统带来了额外的复杂度。还有一些复杂的系统在作出一些微小的改动时，比如修复一个bug，就会因为复杂度的陡然增长而引出一些新的bug。</p><h3 id="1-2-2-Maintaining-High-Utilization"><a href="#1-2-2-Maintaining-High-Utilization" class="headerlink" title="1.2.2 Maintaining High Utilization"></a>1.2.2 Maintaining High Utilization</h3><p>一个最最常见的带来复杂度的需求就是要求系统能够高性能或高效率。</p><blockquote><p><strong>The law of diminishing returns</strong><br>The more one improves some measure of goodness, the more effort the next improvement will require.</p></blockquote><p>一个意图高效率去利用资源而出现的最显而易见的现象就是：越想把所有的资源用到极致，就越需要有更复杂的策略来利用、安置和调配这些资源。文中举了汽车能在红灯右转和机场调度飞机起降的例子来说明高效率就需要更复杂的调度系统。</p><p>图 1.2 高效率和复杂度之间的关系：</p><p><img src="http://p6ayvlg30.bkt.clouddn.com/屏幕快照 2018-03-25 上午12.34.18.png" alt=""><br><em>注解：图 1.1 和 图 2.2 是类似的。</em></p><h2 id="1-3-Coping-with-Complexity"><a href="#1-3-Coping-with-Complexity" class="headerlink" title="1.3 Coping with Complexity"></a>1.3 Coping with Complexity</h2><p>解决系统设计中问题复杂度的方法有：</p><ul><li>modularity（模块化）</li><li>abstraction (抽象化）</li><li>layering (层次化）</li><li>hierarchy（结构化）</li></ul><p><em>注解：和很多其它领域的设计方法是相通的，比如芯片设计和建筑设计等</em></p><h3 id="1-3-1-Modularity"><a href="#1-3-1-Modularity" class="headerlink" title="1.3.1 Modularity"></a>1.3.1 Modularity</h3><p>最简单且最重要的减少复杂度的方法就是“分治法（divide-and-conquer)”：把整个系统看做一堆交互的子系统即模块，来分析和设计。 文中举了如果把一个系统分成K个模块，debug的时间可以从 N^2 下降到 N^2 /K：</p><p>$ DebugTime \approx \dfrac{N^2}{K} $</p><p>模块化的好处还有可以轻松的替换系统中的模块，简化系统的升级过程。</p><blockquote><p><strong>The unyielding foundations rule</strong><br>It is easier to change a module than to change the modularity.</p></blockquote><p><em>注解：因为接口的更换会影响多个相关的模块，所以能否正确的模块化很重要。</em></p><h3 id="1-3-2-Abstraction"><a href="#1-3-2-Abstraction" class="headerlink" title="1.3.2 Abstraction"></a>1.3.2 Abstraction</h3><p><strong>Abstraction</strong> - 抽象化，在模块化过程中找到最佳的边界，是的模块之间的交互较少且相互的影响也少。更通俗的说，模块会被外界看做一个整体，之关心它的外部接口规格而忽略其内部结构。</p><p><strong>functional modularity</strong> - 通过抽象方式来模块化。</p><p><em>注解：合理地抽象化模块堆限制系统错误很重要，因为有效地控制住了模块间的相互影响。</em></p><blockquote><p><strong>The robustness principle</strong><br>Be tolerant of inputs and strict on outputs.</p></blockquote><p><em>注解：模块接口设计要宽进严出，尽可能地大范围接受输入，同时能抑制住错误的输出。</em></p><p><strong>The robustness principle</strong>在计算机系统设计中扮演者重要的角色，特别是在人机交互，网络协议和容错系统中，构成了数字逻辑世界的基础。与之相关且同等重要的设计原理是：</p><blockquote><p><strong>The safety margin principle</strong><br>Keep track of the distance to the cliff, or you may fall over the edge.</p></blockquote><p><em>注解：关注模块输入的边界值。</em></p><p>接受任何一个合理的输入，但关注那些已经快超出限制范围的值，在其失效前尝试修复它。</p><h3 id="1-3-3-Layering"><a href="#1-3-3-Layering" class="headerlink" title="1.3.3 Layering"></a>1.3.3 Layering</h3><p><strong>layering</strong> - 层次化，通过某种方式把模块组织在一起以减少模块间的相互连接。</p><p><em>注解：架构设计中经常看到的分成设计，比如持久层，业务层，展示层等等，还有计算机体系架构<sup id="fnref:5"><a href="#fn:5" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="计算机系统体系架构可以简单分为三层：硬件、操作系统和应用程序。">[5]</span></a></sup>、网络七层架构（OSI）<sup id="fnref:6"><a href="#fn:6" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[开放式系统互联通信参考模型](https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B)（英语：Open System Interconnection Reference Model，缩写为 OSI），共有七层架构。">[6]</span></a></sup>也类似。</em></p><p>层次中的模块除了和同层次中的模块交互外，还可以和紧邻自己的“上层”和“下层”中的模块交互。</p><h3 id="1-3-4-Hierarchy"><a href="#1-3-4-Hierarchy" class="headerlink" title="1.3.4 Hierarchy"></a>1.3.4 Hierarchy</h3><p><strong>hierarchy</strong> - 结构化，从低向上地将模块逐渐组合成子系统，子系统在合成更大的子系统，最终形成一个完整的系统。</p><p><em>注解：本书中这里的hierarchy是通过bottom-up的方式来阐述的，现实中还有一种top-down的说法。</em></p><p>结构化的最大优点就是杜绝了模块随意与其它模块交互的情况，而是只关注其子系统中模块的的接口。</p><h3 id="1-3-5-Putting-it-Back-Together-Names-Make-Connections"><a href="#1-3-5-Putting-it-Back-Together-Names-Make-Connections" class="headerlink" title="1.3.5 Putting it Back Together: Names Make Connections"></a>1.3.5 Putting it Back Together: Names Make Connections</h3><p>在计算机系统中，一个模块通过赋予另一个模块职责（命名）而将模块之间联系起来。</p><p><strong>Binding</strong> -  从多种方式中选择一个合适的实现方式来连接各种模块。</p><p>系统设计者有时为了保证系统的高灵活性，会等所有模块都齐备后才开始绑定模块。推迟绑定的一种方式就是指定其职责（命名）而并不去真正地实现它们。</p><p><strong>indirection</strong> - 重定向，通过命名的方式来更换绑定（binding）。</p><blockquote><p><strong>Decouple modules with indirection</strong><br>Indirection supports replaceability.</p></blockquote><h2 id="1-4-COMPUTER-SYSTEMS-ARE-THE-SAME-BUT-DIFFERENT"><a href="#1-4-COMPUTER-SYSTEMS-ARE-THE-SAME-BUT-DIFFERENT" class="headerlink" title="1.4 COMPUTER SYSTEMS ARE THE SAME BUT DIFFERENT"></a>1.4 COMPUTER SYSTEMS ARE THE SAME BUT DIFFERENT</h2><p>计算机系统设计和其它领域的系统设计有共通的地方，但计算机系统却在两个地方与其它系统天差地别：</p><ul><li>计算机系统的复杂度没有具体的物理定律来约束和限制；</li><li>计算机技术的发展无法准确的预测。</li></ul><h3 id="1-4-1-Computer-Systems-have-no-Nearby-Bounds-on-Composition"><a href="#1-4-1-Computer-Systems-have-no-Nearby-Bounds-on-Composition" class="headerlink" title="1.4.1 Computer Systems have no Nearby Bounds on Composition"></a>1.4.1 Computer Systems have no Nearby Bounds on Composition</h3><p>由于数字硬件（没有模拟硬件的噪声影响）和软件（无物理限制）上天然没有壁垒，一个胆大的设计者会误用模块化、抽象化、层次化和结构化这些工具还构造出一个复杂的庞然大物。不同其他领悟的系统，计算机系统的组合极限甚至可以等同于设计者思维的极限。<br><em>注解：只有思维能束缚住计算机设计系统的大小，设计者需要自己来为系统划定边界。</em></p><h3 id="1-4-2-d-technology-dt-is-Unprecedented"><a href="#1-4-2-d-technology-dt-is-Unprecedented" class="headerlink" title="1.4.2 d(technology)/dt is Unprecedented"></a>1.4.2 d(technology)/dt is Unprecedented</h3><blockquote><p><strong>The incommensurate scaling rule</strong><br>Changing any system parameter by a factor of 10 usually requires a new design.</p></blockquote><p>计算机行业的日新月异也导致了系统的更新换代更频繁，设计师更关注新的设计而无暇顾及老系统的存在的问题。而且技术的高速发展也为很多问题带来了一种暴力的解决方式（花更多钱，等更快的硬件，用最新的算法），反而在计算机系统设计中也是一种正确的选择。<br><em>注解：人吃透计算机系统设计中奥妙的时间远远追不上整个行业技术更新换代的时间。经常一些涌现出来的新技术很容易就可以替代以前的设计方式。</em></p><h2 id="1-5-COPING-WITH-COMPLEXITY-II"><a href="#1-5-COPING-WITH-COMPLEXITY-II" class="headerlink" title="1.5 COPING WITH COMPLEXITY II"></a>1.5 COPING WITH COMPLEXITY II</h2><p>因为计算机系统如此复杂，所以设计者还需要其他额外的方法。</p><h3 id="1-5-1-Why-Modularity-Abstraction-Layering-and-Hierarchy-aren’t-Enough"><a href="#1-5-1-Why-Modularity-Abstraction-Layering-and-Hierarchy-aren’t-Enough" class="headerlink" title="1.5.1 Why Modularity, Abstraction, Layering, and Hierarchy aren’t Enough."></a>1.5.1 Why Modularity, Abstraction, Layering, and Hierarchy aren’t Enough.</h3><p>上面提到的四种设计方法是需要用户很清楚系统应该怎么来设计时下才能发挥作用，但在现实中计算机系统日新月异的变化下，设计者很难如大海捞针般去选择：</p><ul><li><strong>正确</strong>的模块化；</li><li><strong>正确</strong>的抽象化；</li><li><strong>正确</strong>的层次化；</li><li><strong>正确</strong>的结构化。</li></ul><p>即使有一些所谓的设计原则和指导，也都来自与之前系统的一些经验。所以设计者又找到了另一个处理复杂度的技术 —— 迭代。</p><h3 id="1-5-2-Iteration"><a href="#1-5-2-Iteration" class="headerlink" title="1.5.2 Iteration"></a>1.5.2 Iteration</h3><p>迭代就是先从一个最简单，满足最基本需求的系统开始设计开发，然后逐渐扩展和完善其它的需求的过程。成的迭代方法需要有正确的远见，其中就包含了两条设计的原理：</p><blockquote><p><strong>Design for Iteration</strong><br>You won’t get it right the first time, so make it easy to change.</p></blockquote><p><em>注解：迭代就要去拥抱变化，了解自己的系统在需要改变是应该调整哪些地方。</em></p><ul><li>Take small steps.（小心谨慎）</li><li>Don’t rush.(循序渐进)</li><li>Plan for feedback.(感知反馈）</li><li>Study failures.（吸取教训）</li></ul><blockquote><p><strong>Keep digging</strong><br>Complex systems fails for complex reasons.</p></blockquote><p>在迭代的实施过程也会受到一些阻碍，主要包括：</p><ul><li>在迭代过程中容易迷失方向，难把控全局；</li><li>迭代中报喜不报忧，坏消息会被有意或无意的隐藏起来；</li><li>模块的重构有较大阻力，一个原因可能是系统本身重构难度大，另一个原因则是设计者难以割舍自己之前的付出；</li><li>初期迭代的成功让设计者低估了后面的困难，过度地增加新功能，导致了<strong>second-system effect</strong><sup id="fnref:7"><a href="#fn:7" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[第二系统效应](https://zh.wikipedia.org/wiki/第二系統效應)(英语：second-system effect），又称第二系统症候群（英语： second-system syndrome），由佛瑞德·布鲁克斯在《人月神话》中提出的经验概括。它认为，在完成一个小型、优雅而成功的系统之后，人们倾向于对下一个计划有过度的期待，可能因此建造出一个巨大、有各种特色的怪兽系统。第二系统效应可能造成软件专案计划过度设计，产生太多变数，过度复杂，无法达成期待，并因而失败。">[7]</span></a></sup>。</li></ul><h3 id="1-5-3-Keep-it-Simple"><a href="#1-5-3-Keep-it-Simple" class="headerlink" title="1.5.3 Keep it Simple"></a>1.5.3 Keep it Simple</h3><p>最后也是最重要的，一个处理复杂度最行之有效的方法，同时也是最知易行难的方法就是——简单化。但就如前面提到的计算机系统没有明显的自然和物理边界来限制住它的复杂性，所以需要设计者来认为的设定这些边界，但这确实对于设计者来说太有挑战性了。</p><blockquote><p><strong>Adopt sweeping simplifications</strong><br>So you can see what you are doing.</p></blockquote><p><em>注解：设计者要时刻把”如何让系统更简单“放在心上。</em></p><h2 id="WHAT-THE-REST-OF-THIS-BOOK-IS-ABOUT"><a href="#WHAT-THE-REST-OF-THIS-BOOK-IS-ABOUT" class="headerlink" title="WHAT THE REST OF THIS BOOK IS ABOUT"></a>WHAT THE REST OF THIS BOOK IS ABOUT</h2><ul><li>The pervasive importance of modularity(无处不在的模块化）</li><li>Principle-based system design（理论指导实践）</li><li>Making system robust and resilient（让系统更健壮，有更强的适应性）</li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">0.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://en.wikipedia.org/wiki/Scalability" target="_blank" rel="noopener">Scalability</a> 和 Scaling 在计算机术语中都是特指系统在所运行所需的资源增加或减少的同时，系统性能可以成比例的增加或降低的可扩展性或伸缩性。但这里用“扩长”更能表达原文的本意。<a href="#fnref:0" rev="footnote"> ↩</a></span></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E8%9D%B4%E8%9D%B6%E6%95%88%E5%BA%94" target="_blank" rel="noopener">蝴蝶效应</a> (Butterfly effect)是指在一个动态系统中，初始条件下微小的变化能带动整个系统的长期的巨大的连锁反应，是一种混沌的现象。“蝴蝶效应”在混沌学中也常出现。<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">芯片设计时往往要权衡性能（频率越高性能越好）、功耗（低功耗，特别是手机或便携设备），面积（芯片的制造成本）三者之间的关系，达到最优的结果。<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">螺旋模型</a>是一种演化软件开发过程模型，它兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">敏捷软件开发</a>，又称敏捷开发，是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。<a href="#fnref:4" rev="footnote"> ↩</a></span></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">5.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">计算机系统体系架构可以简单分为三层：硬件、操作系统和应用程序。<a href="#fnref:5" rev="footnote"> ↩</a></span></li><li id="fn:6"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">6.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">开放式系统互联通信参考模型</a>（英语：Open System Interconnection Reference Model，缩写为 OSI），共有七层架构。<a href="#fnref:6" rev="footnote"> ↩</a></span></li><li id="fn:7"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">7.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%BA%8C%E7%B3%BB%E7%B5%B1%E6%95%88%E6%87%89" target="_blank" rel="noopener">第二系统效应</a>(英语：second-system effect），又称第二系统症候群（英语： second-system syndrome），由佛瑞德·布鲁克斯在《人月神话》中提出的经验概括。它认为，在完成一个小型、优雅而成功的系统之后，人们倾向于对下一个计划有过度的期待，可能因此建造出一个巨大、有各种特色的怪兽系统。第二系统效应可能造成软件专案计划过度设计，产生太多变数，过度复杂，无法达成期待，并因而失败。<a href="#fnref:7" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CHARPTER-1-Systems&quot;&gt;&lt;a href=&quot;#CHARPTER-1-Systems&quot; class=&quot;headerlink&quot; title=&quot;CHARPTER 1 Systems&quot;&gt;&lt;/a&gt;CHARPTER 1 Systems&lt;/h1&gt;&lt;h2 id=&quot;OVERVIEW&quot;&gt;&lt;a href=&quot;#OVERVIEW&quot; class=&quot;headerlink&quot; title=&quot;OVERVIEW&quot;&gt;&lt;/a&gt;OVERVIEW&lt;/h2&gt;&lt;p&gt;系统设计者需要有一个全局的、整体的计算机系统观（包括软件方面和硬件方面的）。&lt;br&gt;许多有价值的计算机应用程序都具备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容错性&lt;/li&gt;
&lt;li&gt;并发一致性&lt;/li&gt;
&lt;li&gt;离散数据的关联性&lt;/li&gt;
&lt;li&gt;信息的多样性&lt;/li&gt;
&lt;li&gt;对错误和内部攻击的保护性&lt;/li&gt;
&lt;li&gt;与许多用户的交互性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算机系统设计的问题同样可以参考许多其它领域的设计问题，因为他们都有一定的共性。&lt;br&gt;&lt;strong&gt;System design principles&lt;/strong&gt; - 一种可以帮助系统设计者避免犯错的规则，指导或者经验，并不是不能违背的条例。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Avoid excessive generality&lt;/strong&gt;&lt;br&gt;If it’s good for everything, it’s good for nothing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;注解：系统设计的精髓——Everything is Tradeoff。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://shaqsnake.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="computer design" scheme="http://shaqsnake.github.io/tags/computer-design/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机通过Mac主机访问SS</title>
    <link href="http://shaqsnake.github.io/2018/03/24/surf-internet-in-vm-with-ss.html"/>
    <id>http://shaqsnake.github.io/2018/03/24/surf-internet-in-vm-with-ss.html</id>
    <published>2018-03-23T18:08:54.000Z</published>
    <updated>2018-03-29T15:04:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><em>因为需要用到Linux系统来做一些课程的Lab，所以今天去下载了<a href="https://www.virtualbox.org/" target="_blank" rel="noopener">VirtulBox</a>和<a href="http://releases.ubuntu.com/14.04/" target="_blank" rel="noopener">Ubuntu 14.04.5 LTS</a>。安装完成后为了能和平时一样通过SS来上网，搜寻了一下网上的教程，但最后的设置过程和教程都不太一样，特此记录一下。</em><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">宿主OS：MacOS High Sierra(10.13.3)</span><br><span class="line">ShadowSocks: ShadowsocksX-NG 1.7.0</span><br><span class="line">VM: VirtualBox 5.2.8</span><br></pre></td></tr></table></figure></p><p>首先打开SS的<strong>设置</strong>中的<strong>偏好设置</strong>：</p><p><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-24%20%E4%B8%8B%E5%8D%882.19.15.png" alt="屏幕快照 2018-03-24 下午2.19.15"></p><p>在<strong>高级</strong>和<strong>HTTP</strong>两个tab菜单中分别把IP地址设为0.0.0.0，并记住两个选单中的监听端口：</p><p><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-24%20%E4%B8%8B%E5%8D%882.24.56.png" alt="屏幕快照 2018-03-24 下午2.24.56"><br><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-24%20%E4%B8%8B%E5%8D%882.25.09.png" alt="屏幕快照 2018-03-24 下午2.25.09"></p><p>这样做的目的是让宿主主机能在LAN中被访问到。<br>接着启动自己已经安装好的Ubuntu系统后，打开<strong>Terminal</strong>，输入命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route show</span><br></pre></td></tr></table></figure></p><p>可以查到宿主主机的IP地址如下，这里我们的宿主IP为<em>10.0.2.2</em>。</p><p><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-24%20%E4%B8%8B%E5%8D%882.12.42.png" alt="屏幕快照 2018-03-24 下午2.12.42"></p><p>然后进入Ubuntu<strong>System Settings(系统设置)</strong> - <strong>Network(网络)</strong>，选择 <strong>Network proxy(代理)</strong>，按下图所示把宿主的IP和对应的监听地址填好。这里我HTTP/HTTPS填的是SS HTTP监听端口，FTP和Socket填的是SS Socks5的监听端口，有些教程里好像都填Socks5的监听端口也是可以的。</p><p><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-24%20%E4%B8%8B%E5%8D%882.31.38.png" alt="屏幕快照 2018-03-24 下午2.31.38"></p><p>最后，打开Firefox或者通过命令来测试下即可。<br><img src="/media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-24%20%E4%B8%8B%E5%8D%883.03.31.png" alt="屏幕快照 2018-03-24 下午3.03.31"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;因为需要用到Linux系统来做一些课程的Lab，所以今天去下载了&lt;a href=&quot;https://www.virtualbox.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VirtulBox&lt;/a&gt;和&lt;a href=&quot;http://releases.ubuntu.com/14.04/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu 14.04.5 LTS&lt;/a&gt;。安装完成后为了能和平时一样通过SS来上网，搜寻了一下网上的教程，但最后的设置过程和教程都不太一样，特此记录一下。&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="virtualbox" scheme="http://shaqsnake.github.io/tags/virtualbox/"/>
    
      <category term="shadowsocks" scheme="http://shaqsnake.github.io/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>用Python实现设计模式——建造者模式和原型模式</title>
    <link href="http://shaqsnake.github.io/2018/02/01/builder-and-prototype-in-python.html"/>
    <id>http://shaqsnake.github.io/2018/02/01/builder-and-prototype-in-python.html</id>
    <published>2018-02-01T13:21:32.000Z</published>
    <updated>2018-03-27T13:53:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前两篇文章介绍了单例模式和工厂模式，这两种设计模式实际上都属于软件工程中的<a href="https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">创建型模式(Creational Pattern)</a>。维基百科有对这类模式的定义：</p><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B" title="软件工程" target="_blank" rel="noopener">软件工程</a>中，<strong>创建型模式</strong> 是处理<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">对象</a> “对象 (计算机科学)”)创建的<a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="noopener">设计模式</a> “设计模式 (计算机)”)，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。<br>创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。</p></blockquote><p>实际上创建型模式的最大作用就是把对象的创建过程和使用过程进行了解耦，对使用者只提供接口而隐藏了具体的实现细节，让软件结构更清晰，更符合单一职责的原则。接下来本文将继续介绍创建型模式中的另两种模式——建造者模式和原型模式，文中的代码已托管在<a href="https://github.com/shaqsnake/DesignPatternWithPython" target="_blank" rel="noopener">Github</a>上。<br><a id="more"></a></p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造者模式(Builder Pattern)与工厂模式类似，也是把产品的实例化过程交给专门的类来实现，不同的是建造者模式更多的是针对现实中一些构成较复杂，有多个组成部分的对象。比如像汽车就由车身、发动机、车轮、方向盘等很多部件组成，而且整个组装的过程可能还要安装一定的顺序进行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""产品</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.body = <span class="keyword">None</span></span><br><span class="line">        self.engine = <span class="keyword">None</span></span><br><span class="line">        self.tire = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        info = (<span class="string">"Name: &#123;&#125;"</span>.format(self.name),</span><br><span class="line">                <span class="string">"Body: &#123;&#125;"</span>.format(self.body),</span><br><span class="line">                <span class="string">"Engine: &#123;&#125;"</span>.format(self.engine),</span><br><span class="line">                <span class="string">"Tire: &#123;&#125;"</span>.format(self.tire))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\n'</span>.join(info)</span><br></pre></td></tr></table></figure></p><p>但是在现实使用时，用户可能并不关心汽车的这些细节和如何将这些部件组装成汽车的，而只是想通过特定的接口和参数获得汽车这个对象。这时就需要将这个复杂的过程抽象到到一个被称作建造者的对象里，建造者来负责构造这些复杂的组成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarBuilder</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""建造者</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.car = Car(<span class="string">"Mercedes"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_body</span><span class="params">(self, body)</span>:</span></span><br><span class="line">        self.car.body = body</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_engine</span><span class="params">(self, engine)</span>:</span></span><br><span class="line">        <span class="string">"""AMG 5.5L V8 biturbo"""</span></span><br><span class="line">        self.car.engine = engine</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_tire</span><span class="params">(self, tire)</span>:</span></span><br><span class="line">        self.car.tire = tire</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">assemble_car</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.car</span><br></pre></td></tr></table></figure></p><p>最后建造者模式中还会引入了一个指挥者类的角色，该类的作用主要是负责精确地控制产品的整个生成过程，根据用户的不同需求返回不同的完整产品对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Engineer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""指挥者</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.builder = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">construct_car</span><span class="params">(self, body, engine, tire)</span>:</span></span><br><span class="line">        self.builder = CarBuilder()</span><br><span class="line">        self.builder.add_body(body)</span><br><span class="line">        self.builder.add_engine(engine)</span><br><span class="line">        self.builder.add_tire(tire)</span><br><span class="line">        <span class="keyword">return</span> self.builder.assemble_car()</span><br></pre></td></tr></table></figure></p><p>只要把需求告诉指挥者，用户就可以获得一个产品的实例，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">engineer = Engineer()</span><br><span class="line">car = engineer.construct_car(</span><br><span class="line">        body=<span class="string">"G63"</span>,</span><br><span class="line">        engine=<span class="string">"AMG 5.5L V8 biturbo"</span>,</span><br><span class="line">        tire=<span class="string">"Michelin 18inch"</span>)</span><br><span class="line">print(car)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line">&gt;Name: Mercedes</span><br><span class="line">&gt;Body: G63</span><br><span class="line">&gt;Engine: AMG <span class="number">5.5L</span> V8 biturbo</span><br><span class="line">&gt;Tire: Michelin <span class="number">18</span>inch</span><br></pre></td></tr></table></figure></p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式(Prototype design pattern)的动机是为了让用户可以通过复制对象获得一个对象的副本。此模式的出现是因为在C++和Java里需要用此模式来更方便的拷贝对象，但在Python中要实现对一个对象的拷贝有更简单办法，我们就在这里简单的举个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"id: &#123;&#125;, x: &#123;&#125;, y: &#123;&#125;"</span>.format(id(self), self.x, self.y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    foo = Foo(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 利用deepcopy获得新对象</span></span><br><span class="line">    <span class="keyword">import</span> copy</span><br><span class="line">    foo1 = copy.deepcopy(foo)</span><br><span class="line">    foo1.x = <span class="number">3</span></span><br><span class="line">    foo1.y = <span class="number">4</span></span><br><span class="line">    print(foo, foo1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 利用__class__方法获得新</span></span><br><span class="line">    foo2 = foo1.__class__(<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    print(foo, foo2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line">&gt;id: <span class="number">4312696592</span>, x: <span class="number">1</span>, y: <span class="number">2</span> id: <span class="number">4312696928</span>, x: <span class="number">3</span>, y: <span class="number">4</span></span><br><span class="line">&gt;id: <span class="number">4312696592</span>, x: <span class="number">1</span>, y: <span class="number">2</span> id: <span class="number">4312697096</span>, x: <span class="number">5</span>, y: <span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>上面我们用两种原型方式实现了对Foo对象的拷贝，第一种是利用Python语言内置的deepcopy，第二种则用了更优雅的<strong>class</strong>方法。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>本文介绍的两种模式在实际使用中并不常见，建造者模式应用在构造一些复杂的对象时，比如需要构建一个HTML对象，窗口对象或者游戏中的建模等等，而原型模式则主要应用于一些需要备份状态的对象或新建对象开销过大的时候。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]<a href="https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前两篇文章介绍了单例模式和工厂模式，这两种设计模式实际上都属于软件工程中的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;创建型模式(Creational Pattern)&lt;/a&gt;。维基百科有对这类模式的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B&quot; title=&quot;软件工程&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;软件工程&lt;/a&gt;中，&lt;strong&gt;创建型模式&lt;/strong&gt; 是处理&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对象&lt;/a&gt; “对象 (计算机科学)”)创建的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;设计模式&lt;/a&gt; “设计模式 (计算机)”)，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。&lt;br&gt;创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上创建型模式的最大作用就是把对象的创建过程和使用过程进行了解耦，对使用者只提供接口而隐藏了具体的实现细节，让软件结构更清晰，更符合单一职责的原则。接下来本文将继续介绍创建型模式中的另两种模式——建造者模式和原型模式，文中的代码已托管在&lt;a href=&quot;https://github.com/shaqsnake/DesignPatternWithPython&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;上。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://shaqsnake.github.io/tags/python/"/>
    
      <category term="builder pattern" scheme="http://shaqsnake.github.io/tags/builder-pattern/"/>
    
      <category term="prototype" scheme="http://shaqsnake.github.io/tags/prototype/"/>
    
      <category term="design pattern" scheme="http://shaqsnake.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>用Python实现设计模式——工厂模式</title>
    <link href="http://shaqsnake.github.io/2018/01/30/factory-in-python.html"/>
    <id>http://shaqsnake.github.io/2018/01/30/factory-in-python.html</id>
    <published>2018-01-30T13:05:33.000Z</published>
    <updated>2018-03-28T19:42:01.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>工厂模式，顾名思义就是我们可以通过一个指定的“工厂”获得需要的“产品”，在设计模式中主要用于抽象对象的创建过程，让用户可以指定自己想要的对象而不必关心对象的实例化过程。这样做的好处是用户只需通过固定的接口而不是直接去调用类的实例化方法来获得一个对象的实例，隐藏了实例创建过程的复杂度，解耦了生产实例和使用实例的代码，降低了维护的复杂性。<br>本文会用Python实现三种工厂模式的简单例子，所有代码都托管在<a href="https://github.com/shaqsnake/DesignPatternWithPython/tree/master/Factory" target="_blank" rel="noopener">Github</a>上。</p><a id="more"></a><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>首先，我们先看一个简单工厂的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mercedes</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""梅赛德斯</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Mercedes-Benz"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""宝马</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BMW"</span></span><br></pre></td></tr></table></figure></p><p>假设我们有两个“产品”分别是<strong>Mercedes</strong>和<strong>BMW</strong>的汽车，如果没有“工厂”来生产它们，我们就要在代码中自己进行实例化，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mercedes = Mercedes()</span><br><span class="line">bmw = BMW()</span><br></pre></td></tr></table></figure></p><p>但现实中，你可能会面对很多汽车产品，而且每个产品的构造参数还不一样，这样在创建实例时会遇到麻烦。这时就可以构造一个“简单工厂”把所有汽车实例化的过程封装在里面。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleCarFactory</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""简单工厂</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span><span class="params">(name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">'mb'</span>:</span><br><span class="line">            <span class="keyword">return</span> Mercedes()</span><br><span class="line">        <span class="keyword">elif</span> name == <span class="string">'bmw'</span>:</span><br><span class="line">            <span class="keyword">return</span> BMW()</span><br></pre></td></tr></table></figure></p><p>有了<strong>SimpleCarFactory</strong>类后，就可以通过向固定的接口传入参数获得想要的对象实例，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 = SimpleCarFactory.product_car(<span class="string">'mb'</span>)</span><br><span class="line">c2 = SimpleCarFactory.product_car(<span class="string">'bmw'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>虽然有了一个简单的工厂，但在实际使用工厂的过程中，我们会发现新问题：如果我们要新增一个“产品”，例如Audi的汽车，我们除了新增一个<strong>Audi</strong>类外还要修改<strong>SimpleCarFactory</strong>内的product_car方法。这样就违背了软件设计中的<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">开闭原则</a>[1]，即在扩展新的类时，尽量不要修改原有代码。所以我们在简单工厂的基础上把<strong>SimpleCarFactory</strong>抽象成不同的工厂，每个工厂对应生成自己的产品，这就是工厂方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""抽象工厂</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    __metaclass__ = abc.ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MercedesFactory</span><span class="params">(AbstractFactory)</span>:</span></span><br><span class="line">    <span class="string">"""梅赛德斯工厂</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Mercedes()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span><span class="params">(AbstractFactory)</span>:</span></span><br><span class="line">    <span class="string">"""宝马工厂</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> BMW()</span><br></pre></td></tr></table></figure></p><p>我们把工厂抽象出来用<a href="https://docs.python.org/2/library/abc.html" target="_blank" rel="noopener">abc模块</a>[2]实现了一个抽象的基类<strong>AbstractFactory</strong>，这样就可以通过特定的工厂来获得特定的产品实例了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 = MercedesFactory().product_car()</span><br><span class="line">c2 = BMWFactory().product_car()</span><br></pre></td></tr></table></figure></p><p>每个工厂负责生产自己的产品也避免了我们在新增产品时需要修改工厂的代码，而只要增加相应的工厂即可。如新增一个Audi产品，只需新增一个<strong>Audi</strong>类和<strong>AudiFactory</strong>类。</p><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>工厂方法虽然解决了我们“修改代码”的问题，但如果我们要生产很多产品，就会发现我们同样需要写很多对应的工厂类。比如如果<strong>MercedesFactory</strong>和<strong>BMWFactory</strong>不仅生产小汽车，还要生产SUV，那我们用工厂方法就要再多构造两个生产SUV的工厂类。所以为了解决这个问题，我们就要再更进一步的抽象工厂类，让一个工厂可以生产同一类的多个产品，这就是抽象工厂。具体实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种小汽车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mercedes_C63</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""梅赛德斯 C63</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Mercedes-Benz: C63"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW_M3</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""宝马 M3</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BMW: M3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#　两种SUV</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mercedes_G63</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""梅赛德斯 G63</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Mercedes-Benz: G63"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW_X5</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""宝马 X5</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BMW: X5"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""抽象工厂</span></span><br><span class="line"><span class="string">    可以生产小汽车外，还可以生产SUV</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    __metaclass__ = abc.ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_suv</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MercedesFactory</span><span class="params">(AbstractFactory)</span>:</span></span><br><span class="line">    <span class="string">"""梅赛德斯工厂</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Mercedes_C63()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_suv</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Mercedes_G63()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span><span class="params">(AbstractFactory)</span>:</span></span><br><span class="line">    <span class="string">"""宝马工厂</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> BMW_M3()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_suv</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> BMW_X5()</span><br></pre></td></tr></table></figure></p><p>我们让基类<strong>AbstractFactory</strong>同时可以生产汽车和SUV，然后令<strong>MercedesFactory</strong>和<strong>BMWFactory</strong>继承<strong>AbstractFactory</strong>并重写product_car和product_suv方法即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c1 = MercedesFactory().product_car()</span><br><span class="line">s1 = MercedesFactory().product_suv()</span><br><span class="line">print(c1, s1)</span><br><span class="line">s2 = BMWFactory().product_suv()</span><br><span class="line">c2 = BMWFactory().product_car()</span><br><span class="line">print(c2, s2)</span><br></pre></td></tr></table></figure></p><p>抽象工厂模式与工厂方法模式最大的区别在于，抽象工厂中的一个工厂对象可以负责多个不同产品对象的创建 ，这样比工厂方法模式更为简单、有效率。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>初学设计模式时会对三种工厂模式的实际应用比较困惑，其实三种模式各有优缺点，应用的场景也不尽相同：</p><ul><li>简单工厂模式适用于需创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂的情况下，而且用户只关心那种类型的实例被创建，并不关心其初始化过程时，比如多种数据库(MySQL/MongoDB)的实例，多种格式文件的解析器(XML/JSON)等。</li><li>工厂方法模式继承了简单工厂模式的优点又有所改进，其不再通过一个工厂类来负责所有产品的创建，而是将具体创建工作交给相应的子类去做，这使得工厂方法模式可以允许系统能够更高效的扩展。实际应用中可以用来实现系统的日志系统等，比如具体的程序运行日志，网络日志，数据库日志等都可以用具体的工厂类来创建。</li><li>抽象工厂模式在工厂方法基础上扩展了工厂对多个产品创建的支持，更适合一些大型系统，比如系统中有多于一个的产品族，且这些产品族类的产品需实现同样的接口，像很多软件系统界面中不同主题下不同的按钮、文本框、字体等等。<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3>[1]<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">维基百科</a><br>[2]<a href="https://docs.python.org/2/library/abc.html" target="_blank" rel="noopener">Python官方文档</a></li></ul><hr><p><em>2018/1/30更新：修改工厂方法的代码示例，新增结论一节。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;工厂模式，顾名思义就是我们可以通过一个指定的“工厂”获得需要的“产品”，在设计模式中主要用于抽象对象的创建过程，让用户可以指定自己想要的对象而不必关心对象的实例化过程。这样做的好处是用户只需通过固定的接口而不是直接去调用类的实例化方法来获得一个对象的实例，隐藏了实例创建过程的复杂度，解耦了生产实例和使用实例的代码，降低了维护的复杂性。&lt;br&gt;本文会用Python实现三种工厂模式的简单例子，所有代码都托管在&lt;a href=&quot;https://github.com/shaqsnake/DesignPatternWithPython/tree/master/Factory&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://shaqsnake.github.io/tags/python/"/>
    
      <category term="design pattern" scheme="http://shaqsnake.github.io/tags/design-pattern/"/>
    
      <category term="factory pattern" scheme="http://shaqsnake.github.io/tags/factory-pattern/"/>
    
  </entry>
  
  <entry>
    <title>用Python实现设计模式——单例模式</title>
    <link href="http://shaqsnake.github.io/2018/01/28/singleton-in-python.html"/>
    <id>http://shaqsnake.github.io/2018/01/28/singleton-in-python.html</id>
    <published>2018-01-28T14:08:54.000Z</published>
    <updated>2018-03-28T19:42:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>单例模式是设计模式（Design Pattern）中最简单、最容易理解的一种，<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科</a>[1]的定义如下：</p><blockquote><p><strong>单例模式</strong>，也叫<strong>单子模式</strong>，是一种常用的<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" title="软件设计模式" target="_blank" rel="noopener">软件设计模式</a>。在应用这个模式时，单例对象的<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">类</a> “类 (计算机科学)”)必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1" title="对象" target="_blank" rel="noopener">对象</a>，这样有利于我们协调系统整体的行为。</p></blockquote><p>单例模式的主要优点是共享资源和减少资源消耗，主要应用于IO或数据库的线程池,缓存,日志,对话和需共享数据的资源等，但是在实现情况中滥用单例模式会带来很多意想不到的问题，本文重点在于介绍几种Python实现单例模式的方法，这里就不再展开论述了。文中所演示的代码都会托管在<a href="https://github.com/shaqsnake/DesignPatternWithPython" target="_blank" rel="noopener">Github</a>上。</p><a id="more"></a><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>首先，我们先尝试用Python内部类（嵌套类）来实现单例模式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    <span class="string">"""单列类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">__MyClass</span>:</span></span><br><span class="line">        <span class="string">"""实际生成实例的类</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">            <span class="string">"""初始化并赋值"""</span></span><br><span class="line">            self.foo = arg</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">            <span class="string">"""返回实例的id和属性值"""</span></span><br><span class="line">            <span class="keyword">return</span> (id(self), self.foo)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    _instance = <span class="keyword">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> Singleton._instance:</span><br><span class="line">            Singleton._instance = Singleton.__MyClass(arg)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Singleton._instance.foo = arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self._instance, attr)</span><br></pre></td></tr></table></figure></p><p>注意实际生成实例的类是内部的 <strong>“__MyClass”</strong> 类，前面的双下划线代表这是一个私有的类，用户不能再外面直接访问它。而在 <strong>“__MyClass”</strong> 类外封装了一个 <strong>“Singleton”</strong> 类，这个类的任务就是在初始化时保证整个上下文中只有一个实例，实现的方式很简单。用一个私有属性__instance_保存当前生成的实例，在初始化时判断实例是否为<em>None</em>，如果是就用 <strong>“__MyClass”</strong> 类生成一个新实例并赋值给__instance_，否就直接返回或调用当前<strong>instance_的实例。最后用 **”</strong>MyClass”** 里的实现的方法测试一下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="string">"""测试"""</span></span><br><span class="line">    s1 = Singleton(<span class="string">"bar"</span>)</span><br><span class="line">    s2 = Singleton(<span class="string">"zoo"</span>)</span><br><span class="line">    print(s1.display())</span><br><span class="line">    print(s2.display())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">&gt;(<span class="number">41706760L</span>, <span class="string">'zoo'</span>)</span><br><span class="line">&gt;(<span class="number">41706760L</span>, <span class="string">'zoo'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h3><p>现在我们考虑将inner class拆分出来，因为在Python类实例化时会调用<a href="https://docs.python.org/2/reference/datamodel.html#object.__new__" target="_blank" rel="noopener">__new__方法</a>[2]来生成实例，所以我们可以先继承 <strong>“Singleton”</strong> 类，然后通过重写基类的__new__方法让其实现单例模式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单例类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    _instance = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    <span class="string">"""实际生成实例的类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">        self.foo = arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (id(self), self.foo)</span><br></pre></td></tr></table></figure></p><p>测试结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s1 = MyClass(<span class="string">"bar"</span>)</span><br><span class="line">    s2 = MyClass(<span class="string">"zoo"</span>)</span><br><span class="line">    print(s1.display())</span><br><span class="line">    print(s2.display())</span><br><span class="line">    <span class="keyword">assert</span> s1 <span class="keyword">is</span> s2</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">&gt;(<span class="number">40882416L</span>, <span class="string">'zoo'</span>)</span><br><span class="line">&gt;(<span class="number">40882416L</span>, <span class="string">'zoo'</span>)</span><br></pre></td></tr></table></figure></p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>第三种就是最常见的用装饰器来实现单列模式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">"""实际生成实例的类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    foo = <span class="string">"foo"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (id(self))</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherClass</span>:</span></span><br><span class="line">    <span class="string">"""另一个类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>装饰器的实现过程是将生成的实例都放到一个名为<em>instances</em>的<strong>Dict</strong>中映射好，这样每次在类初始化时先检查<em>instances</em>中是否已经包含有例化好的实例，有就直接返回是咧，没有则调用类初始化一个并赋值给<em>instances</em>列表。装饰器的好处在于用一个<strong>Dict</strong>列表来管理所有需要实现单例模式的类，更简便和通用化。代码的测试结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s1 = MyClass()</span><br><span class="line">    s1.foo = <span class="string">"bar"</span></span><br><span class="line">    print(s1.display(), s1.foo)</span><br><span class="line">    s2 = MyClass()</span><br><span class="line">    s2.foo = <span class="string">"zoo"</span></span><br><span class="line">    print(s2.display(), s2.foo)</span><br><span class="line">    <span class="keyword">assert</span> s1 <span class="keyword">is</span> s2</span><br><span class="line">    s3 = OtherClass()</span><br><span class="line">    s4 = OtherClass()</span><br><span class="line">    <span class="keyword">assert</span> s3 <span class="keyword">is</span> s4</span><br></pre></td></tr></table></figure></p><h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><p>如果希望不仅仅是通过限制而是在源头上就创建一个单例类，我们需要用到元类来实现，元类可以参考<a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python" target="_blank" rel="noopener">Stackoverflow</a>[3]上的一个解答。简单的说就是Python中的类也是一种对象，被称为类对象。类对象可以通过元类<strong>type</strong>来创建，而在此过程中会调用<strong>type</strong>的__call__方法。所以我们只要在<strong>type</strong>创建类对象的过程中重写__call__方法，在其中加入相应的创建单例的逻辑即可实现单例模式，具体代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""重写，实现单例模式"""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            cls._instance = super(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 指定元类</span></span><br><span class="line">    __metaclass__ = Singleton</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (id(self))</span><br></pre></td></tr></table></figure></p><p>代码的测试与前面类似，这里就不再累述了。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>最后，需要注意的是单例模式在多线程下可能会出现线程安全的问题，这时候就需要在单例的初始化过程中加上线程同步锁来避免，但这样又会降低整体的性能，具体可以参考<a href="http://xiaorui.cc/2016/04/10/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E4%BF%9D%E6%8C%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%94%AF%E4%B8%80/" target="_blank" rel="noopener">这篇文档</a>。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]<a href="https://pandas.pydata.org/pandas-docs/stable/index.html" target="_blank" rel="noopener">维基百科</a><br>[2]<a href="https://docs.python.org/2/reference/datamodel.html#object.__new__" target="_blank" rel="noopener">Python官方文档</a><br>[3]<a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python" target="_blank" rel="noopener">Stackoverflow</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;单例模式是设计模式（Design Pattern）中最简单、最容易理解的一种，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科&lt;/a&gt;[1]的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;单例模式&lt;/strong&gt;，也叫&lt;strong&gt;单子模式&lt;/strong&gt;，是一种常用的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&quot; title=&quot;软件设计模式&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;软件设计模式&lt;/a&gt;。在应用这个模式时，单例对象的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;类&lt;/a&gt; “类 (计算机科学)”)必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1&quot; title=&quot;对象&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对象&lt;/a&gt;，这样有利于我们协调系统整体的行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单例模式的主要优点是共享资源和减少资源消耗，主要应用于IO或数据库的线程池,缓存,日志,对话和需共享数据的资源等，但是在实现情况中滥用单例模式会带来很多意想不到的问题，本文重点在于介绍几种Python实现单例模式的方法，这里就不再展开论述了。文中所演示的代码都会托管在&lt;a href=&quot;https://github.com/shaqsnake/DesignPatternWithPython&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;上。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://shaqsnake.github.io/tags/python/"/>
    
      <category term="design pattern" scheme="http://shaqsnake.github.io/tags/design-pattern/"/>
    
      <category term="singleton" scheme="http://shaqsnake.github.io/tags/singleton/"/>
    
  </entry>
  
  <entry>
    <title>在pandas.DataFrame.to_sql时指定数据库表的列类型</title>
    <link href="http://shaqsnake.github.io/2018/01/24/pandas-DataFrame-to-sql.html"/>
    <id>http://shaqsnake.github.io/2018/01/24/pandas-DataFrame-to-sql.html</id>
    <published>2018-01-24T13:40:21.000Z</published>
    <updated>2018-03-27T13:52:01.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在数据分析并存储到数据库时，Python的Pandas包提供了_to_sql_方法使存储的过程更为便捷，但如果在使用_to_sql_方法前不在数据库建好相对应的表，to_sql则会默认为你创建一个新表，这时新表的列类型可能并不是你期望的。例如我们通过下段代码往数据库中插入一部分数据：<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[<span class="string">'a'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2.0</span>, datetime.now(), <span class="keyword">True</span>]],</span><br><span class="line">                  columns=[<span class="string">'str'</span>, <span class="string">'int'</span>, <span class="string">'float'</span>, <span class="string">'datetime'</span>, <span class="string">'boolean'</span>])</span><br><span class="line">print(df.dtypes)</span><br></pre></td></tr></table></figure></p><p>通过<em>dtypes</em>可知数据类型为<strong>object, int64, float64, datetime64[ns], bool</strong><br>如果把数据通过_to_sql_方法插入到数据库中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line">engine = create_engine(<span class="string">"mysql+mysqldb://&#123;&#125;:&#123;&#125;@&#123;&#125;/&#123;&#125;"</span>.format(<span class="string">'username'</span>, <span class="string">'password'</span>, <span class="string">'host:port'</span>, <span class="string">'database'</span>))</span><br><span class="line">con = engine.connect()</span><br><span class="line"></span><br><span class="line">df.to_sql(name=<span class="string">'test'</span>, con=con, if_exists=<span class="string">'append'</span>, index=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></p><p>用MySQL的<em>desc</em>可以发现数据库自动创建了表并默认指定了列的格式：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在MySQL中查看表的列类型</span><br><span class="line">desc test;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>Filed</th><th>Type</th><th>Null</th><th>Key</th><th>Default</th><th>Extra</th></tr></thead><tbody><tr><td>str</td><td>text</td><td>YES</td><td></td><td>NULL</td><td></td><td></td></tr><tr><td>int</td><td>bigint(20)</td><td>YES</td><td></td><td>NULL</td><td></td><td></td></tr><tr><td>float</td><td>double</td><td>YES</td><td></td><td>NULL</td><td></td><td></td></tr><tr><td>datetime</td><td>datetime</td><td>YES</td><td></td><td>NULL</td><td></td><td></td></tr><tr><td>boolean</td><td>tinyint(1)</td><td>YES</td><td></td><td>NULL</td><td></td><td></td></tr></tbody></table><p>其中str类型的数据在数据库表中被映射成text，int类型被映射成bigint(20)， float类型被映射成double类型。数据库中的列类型可能并非是我们所期望的格式，但我们又不想在数据插入前手动的创建数据库的表，而更希望根据DataFrame中数据的格式动态地改变数据库中表格式。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>通过查阅<a href="https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_sql.html" target="_blank" rel="noopener">pandas.DataFrame.to_sql</a>的api文档[1]，可以通过指定dtype 参数值来改变数据库中创建表的列类型。</p><blockquote><p><strong>dtype</strong> : <em>dict of column name to SQL type, default None</em><br>Optional specifying the datatype for columns. The SQL type should be a SQLAlchemy type, or a string for sqlite3 fallback connection.</p></blockquote><p>根据描述，可以在执行to_sql方法时，将映射好列名和指定类型的dict赋值给dtype参数即可上，其中对于MySQL表的列类型可以使用SQLAlchemy包中封装好的类型。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 执行前先在MySQL中删除表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy.types <span class="keyword">import</span> NVARCHAR, Float, Integer</span><br><span class="line">dtypedict = &#123;</span><br><span class="line">  <span class="string">'str'</span>: NVARCHAR(length=<span class="number">255</span>),</span><br><span class="line">  <span class="string">'int'</span>: Integer(),</span><br><span class="line">  <span class="string">'float'</span> Float()</span><br><span class="line">&#125;</span><br><span class="line">df.to_sql(name=<span class="string">'test'</span>, con=con, if_exists=<span class="string">'append'</span>, index=<span class="keyword">False</span>, dtype=dtypedict)</span><br></pre></td></tr></table></figure><p>更新代码后，再查看数据库，可以看到数据库在建表时会根据dtypedict中的列名来指定相应的类型。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc test;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>Filed</th><th>Type</th><th>Null</th><th>Key</th><th>Default</th><th>Extra</th></tr></thead><tbody><tr><td>str</td><td>varchar(255)</td><td>YES</td><td></td><td>NULL</td><td></td><td></td></tr><tr><td>int</td><td>int(11)</td><td>YES</td><td></td><td>NULL</td><td></td><td></td></tr><tr><td>float</td><td>float</td><td>YES</td><td></td><td>NULL</td><td></td><td></td></tr><tr><td>datetime</td><td>datetime</td><td>YES</td><td></td><td>NULL</td><td></td><td></td></tr><tr><td>boolean</td><td>tinyint(1)</td><td>YES</td><td></td><td>NULL</td><td></td><td></td></tr></tbody></table><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>通过分析，我们已经知道在执行_to_sql_的方法时，可以通过创建一个类似“<strong>{“column_name”：sqlalchemy_type}</strong>”的映射结构来控制数据库中表的列类型。但在实际使用时，我们更希望能通过pandas.DataFrame中的column的数据类型来映射数据库中的列类型，而不是每此都要列出pandas.DataFrame的column名字。<br>写一个简单的def将pandas.DataFrame中列名和预指定的类型映射起来即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapping_df_types</span><span class="params">(df)</span>:</span></span><br><span class="line">    dtypedict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> zip(df.columns, df.dtypes):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"object"</span> <span class="keyword">in</span> str(j):</span><br><span class="line">            dtypedict.update(&#123;i: NVARCHAR(length=<span class="number">255</span>)&#125;)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"float"</span> <span class="keyword">in</span> str(j):</span><br><span class="line">            dtypedict.update(&#123;i: Float(precision=<span class="number">2</span>, asdecimal=<span class="keyword">True</span>)&#125;)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"int"</span> <span class="keyword">in</span> str(j):</span><br><span class="line">            dtypedict.update(&#123;i: Integer()&#125;)</span><br><span class="line">    <span class="keyword">return</span> dtypedict</span><br></pre></td></tr></table></figure></p><p>只要在执行_to_sql_前使用此方法获得一个映射dict再赋值给_to_sql_的dtype参数即可，执行的结果与上一节相同，不再累述。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame([[<span class="string">'a'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2.0</span>, datetime.now(), <span class="keyword">True</span>]],</span><br><span class="line">                  columns=[<span class="string">'str'</span>, <span class="string">'int'</span>, <span class="string">'float'</span>, <span class="string">'datetime'</span>, <span class="string">'boolean'</span>])</span><br><span class="line">dtypedict = mapping_df_types(df)</span><br><span class="line">df.to_sql(name=<span class="string">'test'</span>, con=con, if_exists=<span class="string">'append'</span>, index=<span class="keyword">False</span>, dtype=dtypedict)</span><br></pre></td></tr></table></figure></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]<a href="https://pandas.pydata.org/pandas-docs/stable/index.html" target="_blank" rel="noopener">pandas官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;在数据分析并存储到数据库时，Python的Pandas包提供了_to_sql_方法使存储的过程更为便捷，但如果在使用_to_sql_方法前不在数据库建好相对应的表，to_sql则会默认为你创建一个新表，这时新表的列类型可能并不是你期望的。例如我们通过下段代码往数据库中插入一部分数据：&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://shaqsnake.github.io/tags/python/"/>
    
      <category term="pandas" scheme="http://shaqsnake.github.io/tags/pandas/"/>
    
  </entry>
  
</feed>
